var documenterSearchIndex = {"docs":
[{"location":"api/#ActuaryUtilities.jl","page":"API","title":"ActuaryUtilities.jl","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"DocTestSetup = quote\n    using ActuaryUtilities\n    using Dates\nend","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [ActuaryUtilities]","category":"page"},{"location":"api/#ActuaryUtilities.KeyRate","page":"API","title":"ActuaryUtilities.KeyRate","text":"KeyRate(timepoints,shift=0.001)\n\nA convenience constructor for KeyRateZero. \n\nExtended Help\n\nKeyRateZero is chosen as the default constructor because it has more attractive properties than KeyRatePar:\n\nrates after the key timepoint remain unaffected by the shift\ne.g. this causes a 6-year zero coupon bond would have a negative duration if the 5-year par rate was used\n\n\n\n\n\n","category":"type"},{"location":"api/#ActuaryUtilities.KeyRatePar","page":"API","title":"ActuaryUtilities.KeyRatePar","text":"KeyRatePar(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration. \n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDurations are computed via a shift-and-compute the yield curve approach.\n\nKeyRatePar is more commonly reported (than KayRateZero) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the Yields.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"api/#ActuaryUtilities.KeyRateZero","page":"API","title":"ActuaryUtilities.KeyRateZero","text":"KeyRateZero(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration.\n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDuration is computed via a shift-and-compute the yield curve approach.\n\nKeyRateZero is less commonly reported (than KayRatePar) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the Yields.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"api/#ActuaryUtilities.CTE-Tuple{Any, Any}","page":"API","title":"ActuaryUtilities.CTE","text":"CTE(v::AbstractArray,p::Real;rev::Bool=false)\n\nThe average of the values ≥ the pth percentile of the vector v is the Conditiona Tail Expectation. Assumes more positive values are higher risk measures, so a higher p will return a more positive number, but this can be reversed if rev is true.\n\nMay also be called with ConditionalTailExpectation(...).\n\nAlso known as Tail Value at Risk (TVaR), or Tail Conditional Expectation (TCE)\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.ConditionalTailExpectation","page":"API","title":"ActuaryUtilities.ConditionalTailExpectation","text":"CTE\n\n\n\n\n\n","category":"function"},{"location":"api/#ActuaryUtilities.VaR-Tuple{Any, Any}","page":"API","title":"ActuaryUtilities.VaR","text":"VaR(v::AbstractArray,p::Real;rev::Bool=false)\n\nThe pth quantile of the vector v is the Value at Risk. Assumes more positive values are higher risk measures, so a higher p will return a more positive number, but this can be reversed if rev is true.\n\nAlso can be called with ValueAtRisk(...).\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.ValueAtRisk","page":"API","title":"ActuaryUtilities.ValueAtRisk","text":"VaR\n\n\n\n\n\n","category":"function"},{"location":"api/#ActuaryUtilities.accum_offset-Tuple{Any}","page":"API","title":"ActuaryUtilities.accum_offset","text":"accum_offset(x; op=*, init=1.0)\n\nA shortcut for the common operation wherein a vector is scanned with an operation, but has an initial value and the resulting array is offset from the traditional accumulate. \n\nThis is a common pattern when calculating things like survivorship given a mortality vector and you want the first value of the resulting vector to be 1.0, and the second value to be 1.0 * x[1], etc.\n\nTwo keyword arguments:\n\nop is the binary (two argument) operator you want to use, such as * or +\ninit is the initial value in the returned array\n\nExamples\n\njulia> accum_offset([0.9, 0.8, 0.7])\n3-element Array{Float64,1}:\n 1.0\n 0.9\n 0.7200000000000001\n\njulia> accum_offset(1:5) # the product of elements 1:n, with the default `1` as the first value\n5-element Array{Int64,1}:\n  1\n  1\n  2\n  6\n 24\n\njulia> accum_offset(1:5,op=+)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  7\n 11\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.breakeven-Union{Tuple{T}, Tuple{T, Vector{T} where T, Vector{T} where T}} where T<:FinanceCore.AbstractYield","page":"API","title":"ActuaryUtilities.breakeven","text":"breakeven(yield, cashflows::Vector)\nbreakeven(yield, cashflows::Vector,times::Vector)\n\nCalculate the time when the accumulated cashflows breakeven given the yield.\n\nAssumptions:\n\ncashflows occur at the end of the period\ncashflows evenly spaced with the first one occuring at time zero if times not given\n\nReturns nothing if cashflow stream never breaks even.\n\njulia> breakeven(0.10, [-10,1,2,3,4,8])\n5\n\njulia> breakeven(0.10, [-10,15,2,3,4,8])\n1\n\njulia> breakeven(0.10, [-10,-15,2,3,4,8]) # returns the `nothing` value\n\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.convexity-Tuple{Any, Any, Any}","page":"API","title":"ActuaryUtilities.convexity","text":"convexity(yield,cfs,times)\nconvexity(yield,valuation_function)\n\nCalculates the convexity.     - yield should be a fixed effective yield (e.g. 0.05).     - times may be omitted and it will assume cfs are evenly spaced beginning at the end of the first period.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5\njulia> cfs = [0,0,0,0,100]\njulia> duration(0.03,cfs,times)\n4.854368932038834\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.duration-Tuple{ActuaryUtilities.KeyRateDuration, Any, Any, Any, Any}","page":"API","title":"ActuaryUtilities.duration","text":"duration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any Yields.jl curve (e.g. does not have to be a curve constructed via Yields.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = Yields.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.duration-Tuple{Dates.Date, Dates.Date}","page":"API","title":"ActuaryUtilities.duration","text":"duration(d1::Date, d2::Date)\n\nCompute the duration given two dates, which is the number of years since the first date. The interval [0,1) is defined as having  duration 1. Can return negative durations if second argument is before the first.\n\njulia> issue_date  = Date(2018,9,30);\n\njulia> duration(issue_date , Date(2019,9,30) ) \n2\njulia> duration(issue_date , issue_date) \n1\njulia> duration(issue_date , Date(2018,10,1) ) \n1\njulia> duration(issue_date , Date(2019,10,1) ) \n2\njulia> duration(issue_date , Date(2018,6,30) ) \n0\njulia> duration(Date(2018,9,30),Date(2017,6,30)) \n-1\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.duration-Tuple{Macaulay, Any, Any, Any}","page":"API","title":"ActuaryUtilities.duration","text":"duration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, or DV01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\ninterest_rate should be a fixed effective yield (e.g. 0.05).\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5\njulia> cfs = [0,0,0,0,100]\njulia> duration(0.03,cfs,times)\n4.854368932038834\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.eurocall-Tuple{}","page":"API","title":"ActuaryUtilities.eurocall","text":"eurocall(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.europut-Tuple{}","page":"API","title":"ActuaryUtilities.europut","text":"europut(;S=1.,K=1.,τ=1,r,σ,q=0.)\n\nCalculate the Black-Scholes implied option price for a european call, where:\n\nS is the current asset price\nK is the strike or exercise price\nτ is the time remaining to maturity (can be typed with \\tau[tab])\nr is the continuously compounded risk free rate\nσ is the (implied) volatility (can be typed with \\sigma[tab])\nq is the continuously paid dividend rate\n\nRates should be input as rates (not percentages), e.g.: 0.05 instead of 5 for a rate of five percent.\n\n!!! Experimental: this function is well-tested, but the derivatives functionality (API) may change in a future version of ActuaryUtilities.\n\nExtended Help\n\nThis is the same as the formulation presented in the dividend extension of the BS model in Wikipedia.\n\nOther general comments:\n\nSwap/OIS curves are generally better sources for r than government debt (e.g. US Treasury) due to the collateralized nature of swap instruments.\n(Implied) volatility is characterized by a curve that is a function of the strike price (among other things), so take care when using \nYields.jl can assist with converting rates to continuously compounded if you need to perform conversions.\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.moic-Tuple{T} where T<:AbstractArray","page":"API","title":"ActuaryUtilities.moic","text":"moic(cashflows<:AbstractArray)\n\nThe multiple on invested capital (\"moic\") is the un-discounted sum of distributions divided by the sum of the contributions. The function assumes that negative numbers in the array represent contributions and positive numbers represent distributions.\n\nExamples\n\njulia> moic([-10,20,30])\n5.0\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.present_value-Union{Tuple{T}, Tuple{T, Any, Any}} where T<:FinanceCore.AbstractYield","page":"API","title":"ActuaryUtilities.present_value","text":"present_value(interest, cashflows::Vector, timepoints)\npresent_value(interest, cashflows::Vector)\n\nDiscount the cashflows vector at the given interest_interestrate,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at times 1,2,...,n.\n\nThe interest can be an InterestCurve, a single scalar, or a vector wrapped in an InterestCurve. \n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Yields.Forward([0.1,0.2]), [10,20],[0,1])\n28.18181818181818 # same as above, because first cashflow is at time zero\n\nExample on how to use real dates using the DayCounts.jl package\n\n\nusing DayCounts \ndates = Date(2012,12,31):Year(1):Date(2013,12,31)\ntimes = map(d -> yearfrac(dates[1], d, DayCounts.Actual365Fixed()),dates) # [0.0,1.0]\npresent_value(0.1, [10,20],times)\n\n# output\n28.18181818181818\n\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.present_values-Tuple{Any, Any}","page":"API","title":"ActuaryUtilities.present_values","text":"present_value(interest, cashflows::Vector, timepoints)\npresent_value(interest, cashflows::Vector)\n\nEfficiently calculate a vector representing the present value of the given cashflows at each period prior to the given timepoint.\n\nExamples\n\njulia> present_values(0.00, [1,1,1])\n[3,2,1]\n\njulia> present_values(Yields.Forward([0.1,0.2]), [10,20],[0,1])\n2-element Vector{Float64}:\n 28.18181818181818\n 18.18181818181818\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.price-Tuple{Any, Any}","page":"API","title":"ActuaryUtilities.price","text":"price(...)\n\nThe absolute value of the present_value(...). \n\nExtended help\n\nUsing price can be helpful if the directionality of the value doesn't matter. For example, in the common usage, duration is more interested in the change in price than present value, so price is used there.\n\n\n\n\n\n","category":"method"},{"location":"api/#ActuaryUtilities.pv","page":"API","title":"ActuaryUtilities.pv","text":"pv()\n\nAn alias for `present_value`.\n\n\n\n\n\n","category":"function"},{"location":"api/#ActuaryUtilities.spread","page":"API","title":"ActuaryUtilities.spread","text":"spread(curve1,curve2,cashflows)\n\nReturn the solved-for constant spread to add to curve1 in order to equate the discounted cashflows with curve2\n\n\n\n\n\n","category":"function"},{"location":"api/#ActuaryUtilities.years_between","page":"API","title":"ActuaryUtilities.years_between","text":"Years_Between(d1::Date, d2::Date)\n\nCompute the number of integer years between two dates, with the  first date typically before the second. Will return negative number if first date is after the second. Use third argument to indicate if calendar  anniversary should count as a full year.\n\nExamples\n\njulia> d1 = Date(2018,09,30);\n\njulia> d2 = Date(2019,09,30);\n\njulia> d3 = Date(2019,10,01);\n\njulia> years_between(d1,d3) \n1\njulia> years_between(d1,d2,false) # same month/day but `false` overlap\n0 \njulia> years_between(d1,d2) # same month/day but `true` overlap\n1 \njulia> years_between(d1,d2) # using default `true` overlap\n1 \n\n\n\n\n\n","category":"function"},{"location":"#Quickstart","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\ndiscount_rate = 0.03\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A collection of common functions/manipulations used in Actuarial Calculations.","category":"page"},{"location":"#Financial-Maths","page":"Introduction","title":"Financial Maths","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"duration:\nCalculate the Macaulay, Modified, or DV01 durations for a set of cashflows\nCalculate the KeyRate(time) (a.k.a. KeyRateZero)duration or KeyRatePar(time) duration\nconvexity for price sensitivity\nFlexible interest rate options via the Yields.jl package.\ninternal_rate_of_return or irr to calculate the IRR given cashflows (including at timepoints like Excel's XIRR)\nbreakeven to calculate the breakeven time for a set of cashflows\naccum_offset to calculate accumulations like survivorship from a mortality vector\nspread will calculate the spread needed between two yield curves to equate a set of cashflows","category":"page"},{"location":"#Options-Pricing","page":"Introduction","title":"Options Pricing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"eurocall and europut for Black-Scholes option prices (note: API may change for this in future)","category":"page"},{"location":"#Risk-Measures","page":"Introduction","title":"Risk Measures","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Calculate risk measures for a given vector of risks:\nCTE for the Conditional Tail Expectation, or\nVaR for the percentile/Value at Risk.","category":"page"},{"location":"#Insurance-mechanics","page":"Introduction","title":"Insurance mechanics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"duration:\nCalculate the duration given an issue date and date (a.k.a. policy duration)","category":"page"},{"location":"#Typed-Rates","page":"Introduction","title":"Typed Rates","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"functions which return a rate/yield will return a Yields.Rate object. E.g. irr(cashflows) will return a Rate(0.05,Periodic(1)) instead of just a 0.05 (float64) to convey the compounding frequency. This uses (and is fully compatible with) Yields.jl and can be used anywhere you would otherwise use a simple floating point rate.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A couple of other notes:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"rate(...) will return the untyped rate from a Yields.Rate struct:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Yields.Rate(0.05,Yields.Periodic(1));\njulia> rate(r) \n0.05","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can still pass a simple floating point rate to various methods. E.g. these two are the same (the default compounding convention is periodic once per period):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"discount(0.05,cashflows)\nr = Yields.Rate(0.05,Yields.Periodic(1));\ndiscount(r,cashflows)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"convert between rates with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"using Yields\nr = Yields.Rate(0.05,Yields.Periodic(1));\nconvert(Yields.Periodic(2),  r)   # convert to compounded twice per timestep\nconvert(Yields.Continuous(2),r)   # convert to compounded twice per timestep","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For more, see the Yields.jl which provides a rich and flexible API for rates and curves to use.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"#Interactive,-basic-cashflow-analysis","page":"Introduction","title":"Interactive, basic cashflow analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See JuliaActuary.org for instructions on running this example.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Simple cashflow analysis with ActuaryUtilities.jl)","category":"page"},{"location":"#Useful-tips","page":"Introduction","title":"Useful tips","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions often use a mix of interest_rates, cashflows, and timepoints. When calling functions, the general order of the arguments is 1) interest rates, 2) cashflows, and 3) timepoints.","category":"page"}]
}
