var documenterSearchIndex = {"docs":
[{"location":"risk_measures/#Risk-Measures","page":"Risk Measures","title":"Risk Measures","text":"","category":"section"},{"location":"risk_measures/#Quickstart","page":"Risk Measures","title":"Quickstart","text":"outcomes = rand(100)\n\n# direct usage\nVaR(0.90)(outcomes) # ≈ 0.90  \nCTE(0.90)(outcomes) # ≈ 0.95  \nWangTransform(0.90)(outcomes) # ≈ 0.81\n\n# construct a reusable object (functor)\nrm = VaR(0.90)\n\nrm(outcomes) # ≈ 0.90","category":"section"},{"location":"risk_measures/#Introduction","page":"Risk Measures","title":"Introduction","text":"Risk measures encompass the set of functions that map a set of outcomes to an output value characterizing the associated riskiness of those outcomes. As is usual when attempting to compress information (e.g. condensing information into a single value), there are multiple ways we can characterize this riskiness.","category":"section"},{"location":"risk_measures/#Coherence-and-Other-Desirable-Properties","page":"Risk Measures","title":"Coherence & Other Desirable Properties","text":"Further, it is desirable that a risk measure has certain properties, and risk measures that meet the first four criteria are called \"Coherent\" in the literature.  From \"An Introduction to Risk Measures for Actuarial Applications\" (Hardy), she describes as follows:\n\nUsing H as a risk measure and X as the associated risk distribution:","category":"section"},{"location":"risk_measures/#1.-Translation-Invariance","page":"Risk Measures","title":"1. Translation Invariance","text":"For any non-random c\n\n%H(X + c) = H(X) + c% This means that adding a constant amount (positive or negative) to a risk adds the same amount to the risk measure. It also implies that the risk measure for a non-random loss, with known value c, say, is just the amount of the loss c.","category":"section"},{"location":"risk_measures/#2.-Positive-Homogeneity","page":"Risk Measures","title":"2. Positive Homogeneity","text":"For any non-random λ  0:\n\nH(λX) = λH(X)\n\nThis axiom implies that changing the units of loss does not change the risk measure.","category":"section"},{"location":"risk_measures/#3.-Subadditivity","page":"Risk Measures","title":"3. Subadditivity","text":"For any two random losses X and Y,\n\nH(X + Y)  H(X) + H(Y)\n\nIt should not be possible to reduce the economic capital required (or the appropriate premium) for a risk by splitting it into constituent parts. Or, in other words, diversification (ie consolidating risks) cannot make the risk greater, but it might make the risk smaller if the risks are less than perfectly correlated.","category":"section"},{"location":"risk_measures/#4.-Monotonicity","page":"Risk Measures","title":"4. Monotonicity","text":"If Pr(X  Y) = 1 then H(X)  H(Y).\n\nIf one risk is always bigger then another, the risk measures should be similarly ordered.","category":"section"},{"location":"risk_measures/#Other-Properties","page":"Risk Measures","title":"Other Properties","text":"In \"Properties of Distortion Risk Measures\" (Balbás, Garrido, Mayoral) also note other properties of interest:","category":"section"},{"location":"risk_measures/#Complete","page":"Risk Measures","title":"Complete","text":"Completeness is the property that the distortion function associated with the risk measure produces a unique mapping between the original risk's survival function S(x) and the distorted  S*(x) for each x. See Distortion Risk Measures for more detail on this.\n\nIn practice, this means that a non-complete risk measure ignores some part of the risk distribution (e.g. CTE and VaR don't use the full distribution and have the same)","category":"section"},{"location":"risk_measures/#Exhaustive","page":"Risk Measures","title":"Exhaustive","text":"A risk measure is \"exhaustive\" if it is coherent and complete.","category":"section"},{"location":"risk_measures/#Adaptable","page":"Risk Measures","title":"Adaptable","text":"A risk measure is \"adapted\" or \"adaptable\" if its distortion function (see Distortion Risk Measures) g:\n\n1. $g$ is strictly concave, that is $g$ is strictly decreasing. \n2. $lim_{u\\to0+} g\\prime(u) = \\inf and lim_{u\\to1-} g\\prime(u) = 0.\n\nAdaptive risk measures are exhaustive but the converse is not true.","category":"section"},{"location":"risk_measures/#Summary-of-Risk-Measure-Properties","page":"Risk Measures","title":"Summary of Risk Measure Properties","text":"Measure Coherent Complete Exhaustive Adaptable Condition 2\nVaR No No No No No\nCTE Yes No No No No\nDualPower (y  1) Yes Yes Yes No Yes\nProportionalHazard (γ  1) Yes Yes Yes No Yes\nWangTransform Yes Yes Yes Yes Yes","category":"section"},{"location":"risk_measures/#Distortion-Risk-Measures","page":"Risk Measures","title":"Distortion Risk Measures","text":"Distortion Risk Measures (Wikipedia Link) are a way of remapping the probabilities of a risk distribution in order to compute a risk measure H on the risk distribution X.\n\nAdapting Wang (2002), there are two key components:","category":"section"},{"location":"risk_measures/#Distortion-Function-g(u)","page":"Risk Measures","title":"Distortion Function g(u)","text":"This remaps values in the [0,1] range to another value in the [0,1] range, and in H below, operates on the survival function S and F=1-S.\n\nLet g01to01 be an increasing function with g(0)=0 and g(1)=1. The transform F^*(x)=g(F(x)) defines a distorted probability distribution, where \"g\" is called a distortion function.\n\nNote that F^* and F are equivalent probability measures if and only if g01to01 is continuous and one-to-one. Definition 4.2. We define a family of distortion risk-measures using the mean-value under the distorted probability F^*(x)=g(F(x)):","category":"section"},{"location":"risk_measures/#Risk-Measure-Integration","page":"Risk Measures","title":"Risk Measure Integration","text":"To calculate a risk measure H, we integrate the distorted F across all possible values in the risk distribution (i.e. x in X):\n\nH(X) = E^*(X) = - int_-infty^0 g(F(x))dx + int_0^+infty1-g(F(x))dx\n\nThat is, the risk measure (H) is equal to the expected value of the distortion of the risk distribution (E^*(X)).","category":"section"},{"location":"risk_measures/#Examples","page":"Risk Measures","title":"Examples","text":"","category":"section"},{"location":"risk_measures/#Basic-Usage","page":"Risk Measures","title":"Basic Usage","text":"outcomes = rand(100)\n\n# direct usage\nVaR(0.90)(outcomes) # ≈ 0.90  \nCTE(0.90)(outcomes) # ≈ 0.95  \nWangTransform(0.90)(outcomes) # ≈ 0.81\n\n# construct a reusable object (functor)\nrm = VaR(0.90)\n\nrm(outcomes) # ≈ 0.90","category":"section"},{"location":"risk_measures/#Comparison","page":"Risk Measures","title":"Comparison","text":"We will generate a random outcome and show how the risk measures behave:\n\nusing Distributions\nusing ActuaryUtilities\nusing CairoMakie\n\noutcomes = Weibull(1,5)\n# or this could be discrete outcomes as in the next line\n#outcomes = rand(LogNormal(2,10)*100,2000) \n\nαs= range(0.00,0.99;length=100)\n\nlet \n    f = Figure()\n    ax = Axis(f[1,1],\n        xlabel=\"α\",\n        ylabel=\"Loss\",\n        title = \"Comparison of Risk Measures\",\n        xgridvisible=false,\n        ygridvisible=false,\n    )\n\n    lines!(ax,\n        αs,\n        [quantile(outcomes, α) for α in αs],\n        label = \"Quantile α of Outcome\",\n        color = :grey10,\n        linewidth = 3,\n        )\n    \n    lines!(ax,\n        αs,\n        [VaR(α)(outcomes) for α in αs],\n        label = \"VaR(α)\",\n        linestyle=:dash\n        )\n    lines!(ax,\n        αs,\n        [CTE(α)(outcomes) for α in αs],\n        label = \"CTE(α)\",\n        )\n    lines!(ax,\n        αs[2:end],\n        [WangTransform(α)(outcomes) for α in αs[2:end]],\n        label = \"WangTransform(α)\",\n        )\n    lines!(ax,\n        αs,\n        [ProportionalHazard(2)(outcomes) for α in αs],\n        label = \"ProportionalHazard(2)\",\n        )\n    \n    lines!(ax,\n        αs,\n        [DualPower(2)(outcomes) for α in αs],\n        label = \"DualPower(2)\",\n        )\n    lines!(ax,\n        αs,\n        [RiskMeasures.Expectation()(outcomes) for α in αs],\n        label = \"Expectation\",\n        )\n    axislegend(ax,position=:lt)\n\n        f\nend","category":"section"},{"location":"risk_measures/#API","page":"Risk Measures","title":"API","text":"","category":"section"},{"location":"risk_measures/#Exported-API","page":"Risk Measures","title":"Exported API","text":"","category":"section"},{"location":"risk_measures/#Unexported-API","page":"Risk Measures","title":"Unexported API","text":"","category":"section"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.CTE","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.CTE","text":"CTE(α)::RiskMeasure\nCTE(α)(risk)::T (where T is the type of values sampled in risk)\n\nThe Conditional Tail Expectation (CTE) at level α is the expected value of the risk distribution above the αth quantile. risk can be a univariate distribution or an array of outcomes. Assumes more positive values are higher risk measures, so a higher p will return a more positive number.\n\nCTE(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0) \n\nExamples\n\njulia> CTE(0.95)(rand(1000))\n0.9766218612020593\n\njulia> rm = CTE(0.95)\nCTE{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.9739835010268733\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ConditionalTailExpectation","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ConditionalTailExpectation","text":"CTE\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.DualPower","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.DualPower","text":"DualPower(v)::RiskMeasure\nDualPower(v)(risk)::T (where T is the type of values sampled in risk)\n\nThe Dual Power distortion risk measure is defined as 1 - (1 - x)^v, where x is the cumulative distribution function (CDF) of the risk distribution and v is a positive parameter. risk can be a univariate distribution or an array of outcomes.\n\nDualPower(v) returns a functor which can then be called on a risk distribution.\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ProportionalHazard","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ProportionalHazard","text":"ProportionalHazard(y)::RiskMeasure\nProportionalHazard(y)(risk)::T (where T is the type of values sampled in risk)\n\nThe Proportional Hazard distortion risk measure is defined as x^(1y), where x is the cumulative distribution function (CDF) of the risk distribution and y is a positive parameter. risk can be a univariate distribution or an array of outcomes. ProportionalHazard(y) returns a functor which can then be called on a risk distribution.\n\nExamples\n\njulia> ProportionalHazard(2)(rand(1000))\n0.6659603556774121\n\njulia> rm = ProportionalHazard(2)\nProportionalHazard{Int64}(2)\n\njulia> rm(rand(1000))\n0.6710587338367799\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.VaR","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.VaR","text":" VaR(α)::RiskMeasure\n VaR(α)(risk)::T (where T is the type of values sampled in `risk`)\n\nThe αth quantile of the risk distribution is the Value at Risk, or αth quantile. risk can be a univariate distribution or an array of outcomes. Assumes more positive values are higher risk measures, so a higher p will return a more positive number. For a discrete risk, the VaR returned is the first value above the αth percentile.\n\nVaR(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0) \n\nExamples\n\njulia> VaR(0.95)(rand(1000))\n0.9561843082268024\n\njulia> rm = VaR(0.95)\nVaR{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.9597070153670079\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ValueAtRisk","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ValueAtRisk","text":"VaR\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.WangTransform","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.WangTransform","text":"WangTransform(α)::RiskMeasure\nWangTransform(α)(risk)::T (where T is the type of values sampled in risk)\n\nThe Wang Transform is a distortion risk measure that transforms the cumulative distribution function (CDF) of the risk distribution using a normal distribution with mean Φ⁻¹(α) and standard deviation 1. risk can be a univariate distribution or an array of outcomes.\n\nWangTransform(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0]\n\nIn the literature, sometimes λ is used where lambda = Phi^-1(alpha).\n\nExamples\n\njulia> WangTransform(0.95)(rand(1000))\n0.8799465543360105\n\njulia> rm = WangTransform(0.95)\nWangTransform{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.8892245759705852\n\nReferences\n\n\"A Risk Measure That Goes Beyond Coherence\", Shaun S. Wang, 2002\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.Expectation","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.Expectation","text":"Expectation()::RiskMeasure\nExpectation()(risk)::T (where T is the type of values sampled in `risk`)\n\nThe expected value of the risk.\n\nExpectation() returns a functor which can then be called on a risk distribution.\n\nExamples\n\njulia> RiskMeasures.Expectation(rand(1000))\n0.4793223308812537\n\njulia> rm = RiskMeasures.Expectation()\nActuaryUtilities.RiskMeasures.Expectation()\n\njulia> rm(rand(1000))\n0.4941708036889741\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.cdf_func-Tuple{AbstractArray{<:Real}}","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.cdf_func","text":"cdf_function(risk)\n\nReturns the appropriate cumulative distribution function depending on the type, specifically:\n\ncdf_func(S::AbstractArray{<:Real}) = StatsBase.ecdf(S)\ncdf_func(S::Distributions.UnivariateDistribution) = x -> Distributions.cdf(S, x)\n\n\n\n\n\n","category":"method"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.g-Tuple{ActuaryUtilities.RiskMeasures.RiskMeasure, Any}","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.g","text":"g(rm::RiskMeasure,x)\n\nThe probability distortion function associated with the given risk measure.\n\nSee Distortion Function g(u)\n\n\n\n\n\n","category":"method"},{"location":"sensitivities/#Key-Rate-Sensitivities","page":"Key Rate Sensitivities","title":"Key Rate Sensitivities","text":"Compute key rate durations, DV01s, and convexities via automatic differentiation using ZeroRateCurve from FinanceModels.jl.\n\nThis approach uses ForwardDiff to differentiate through the curve construction, giving exact (machine-precision) sensitivities in a single pass. See the autodiff ALM chapter for background.","category":"section"},{"location":"sensitivities/#Basic-Usage","page":"Key Rate Sensitivities","title":"Basic Usage","text":"Construct a ZeroRateCurve with continuously-compounded zero rates and tenor times, then pass it to duration, convexity, or sensitivities:\n\nusing ActuaryUtilities, FinanceModels\n\nrates = [0.03, 0.03, 0.03, 0.03, 0.03]\ntenors = [1.0, 2.0, 3.0, 4.0, 5.0]\nzrc = ZeroRateCurve(rates, tenors)\n\ncfs = [5.0, 5.0, 5.0, 5.0, 105.0]\n\n# Scalar modified duration (default)\ndur = duration(zrc, cfs, tenors)\n\n# Scalar DV01\ndv01 = duration(DV01(), zrc, cfs, tenors)\n\n# Scalar convexity\nconv = convexity(zrc, cfs, tenors)\n\nTo get the full key-rate decomposition (vectors/matrices), use KeyRates():\n\n# Key rate durations (modified): vector of -∂V/∂rᵢ / V\nkrds = duration(KeyRates(), zrc, cfs, tenors)\n\n# Key rate DV01s: vector of -∂V/∂rᵢ / 10000\ndv01s = duration(DV01(), KeyRates(), zrc, cfs, tenors)\n\n# Key rate convexity matrix: ∂²V/∂rᵢ∂rⱼ / V\nconv_matrix = convexity(KeyRates(), zrc, cfs, tenors)\n\nFor a complete set of key-rate results in a single AD pass, use sensitivities:\n\nresult = sensitivities(zrc, cfs, tenors)\n# result.value       — present value\n# result.durations   — key rate durations (modified) — vector\n# result.convexities — cross-convexity matrix — matrix\n\n# For DV01s instead of durations:\ndv01_result = sensitivities(DV01(), zrc, cfs, tenors)\n# dv01_result.value       — present value\n# dv01_result.dv01s       — key rate DV01s — vector\n# dv01_result.convexities — cross-convexity matrix — matrix","category":"section"},{"location":"sensitivities/#Using-Cashflow-Objects","page":"Key Rate Sensitivities","title":"Using Cashflow Objects","text":"All ZeroRateCurve-based methods accept Vector{Cashflow} directly, eliminating the need to manually split into amounts and times:\n\nusing ActuaryUtilities, FinanceModels, FinanceCore\n\ncfs = Cashflow.([5.0, 5.0, 5.0, 5.0, 105.0], [1.0, 2.0, 3.0, 4.0, 5.0])\n\n# These are equivalent:\nduration(zrc, cfs)                              # using Cashflow objects\nduration(zrc, [5.0, 5.0, 5.0, 5.0, 105.0], [1.0, 2.0, 3.0, 4.0, 5.0])  # using amounts + times\n\n# Works with all dispatch variants:\nduration(KeyRates(), zrc, cfs)\nduration(DV01(), zrc, cfs)\nduration(DV01(), KeyRates(), zrc, cfs)\nduration(IR01(), base, credit, cfs)\nduration(CS01(), KeyRates(), base, credit, cfs)\nconvexity(zrc, cfs)\nconvexity(KeyRates(), base, credit, cfs)\nsensitivities(zrc, cfs)\nsensitivities(DV01(), base, credit, cfs)","category":"section"},{"location":"sensitivities/#Constructing-a-ZeroRateCurve-from-Other-Models","page":"Key Rate Sensitivities","title":"Constructing a ZeroRateCurve from Other Models","text":"If you have a fitted yield model (e.g. NelsonSiegel, Constant, a bootstrapped spline), convert it to a ZeroRateCurve for key rate analysis:\n\nns = Yield.NelsonSiegel(1.0, 0.04, -0.02, 0.01)\nzrc = ZeroRateCurve(ns, [1.0, 2.0, 5.0, 10.0, 20.0])\n\n# Now use with sensitivities:\nresult = sensitivities(zrc, cfs)","category":"section"},{"location":"sensitivities/#Scalar-vs-Key-Rate-Decomposition","page":"Key Rate Sensitivities","title":"Scalar vs Key-Rate Decomposition","text":"By default, duration and convexity with a ZeroRateCurve return scalars — the total modified duration, DV01, or convexity. This is consistent with the yield-based API (duration(0.03, cfs, times)).\n\nTo obtain the per-tenor decomposition, pass KeyRates() as the first argument:\n\n# Scalar (default) — same as sum of key-rate decomposition\nduration(zrc, cfs, tenors)                          # scalar\nduration(DV01(), zrc, cfs, tenors)                   # scalar\nconvexity(zrc, cfs, tenors)                          # scalar\n\n# Key-rate decomposition\nduration(KeyRates(), zrc, cfs, tenors)               # vector\nduration(DV01(), KeyRates(), zrc, cfs, tenors)       # vector\nconvexity(KeyRates(), zrc, cfs, tenors)              # matrix\n\nThe scalar value equals the sum of the key-rate decomposition:\n\nduration(zrc, cfs, tenors) ≈ sum(duration(KeyRates(), zrc, cfs, tenors))\n\nFor a flat curve, the scalar modified duration matches the yield-based API:\n\nusing ActuaryUtilities\n\ncfs = [5.0, 5.0, 5.0, 5.0, 105.0]\ntenors = [1.0, 2.0, 3.0, 4.0, 5.0]\nzrc = ZeroRateCurve(fill(0.03, 5), tenors)\n\nduration(zrc, cfs, tenors)                            # ≈ 4.57\nduration(0.03, cfs, tenors)                            # ≈ 4.57 (same)\n\nFor Macaulay duration, use the scalar yield API directly — there is no ZeroRateCurve dispatch:\n\nduration(Macaulay(), 0.03, cfs, tenors)","category":"section"},{"location":"sensitivities/#Interest-Sensitive-Instruments","page":"Key Rate Sensitivities","title":"Interest-Sensitive Instruments","text":"For instruments whose cashflows depend on the rate environment (callable bonds, floaters, etc.), use the do-block syntax to pass a custom valuation function:\n\n# Callable bond: key rate durations (vector)\ncallable_krds = duration(KeyRates(), zrc) do curve\n    ncv = pv(curve, cfs, tenors)\n    called_value = pv(curve, cfs[1:3], tenors[1:3]) + 102.0 * curve(3.0)\n    min(ncv, called_value)\nend\n\n# Scalar duration (default)\ncallable_dur = duration(zrc) do curve\n    ncv = pv(curve, cfs, tenors)\n    called_value = pv(curve, cfs[1:3], tenors[1:3]) + 102.0 * curve(3.0)\n    min(ncv, called_value)\nend\n\nThe function receives a curve object and must return a scalar value. ForwardDiff differentiates through the entire valuation, capturing any rate-dependent optionality.","category":"section"},{"location":"sensitivities/#Two-Curve-Decomposition","page":"Key Rate Sensitivities","title":"Two-Curve Decomposition","text":"Decompose sensitivities into base (risk-free) and credit spread components using IR01 and CS01:\n\nbase = ZeroRateCurve([0.03, 0.03, 0.03, 0.03, 0.03], tenors)\ncredit = ZeroRateCurve([0.02, 0.02, 0.02, 0.02, 0.02], tenors)\n\n# Scalar IR01 and CS01\nir01 = duration(IR01(), base, credit, cfs, tenors)\ncs01 = duration(CS01(), base, credit, cfs, tenors)\n\n# Key-rate decomposition (vectors)\nir01s = duration(IR01(), KeyRates(), base, credit, cfs, tenors)\ncs01s = duration(CS01(), KeyRates(), base, credit, cfs, tenors)\n\n# Two-curve convexity — scalars by default\nconv = convexity(base, credit, cfs, tenors)\n# conv.base, conv.credit, conv.cross (all scalars)\n\n# Key-rate decomposition (matrices)\nconv_kr = convexity(KeyRates(), base, credit, cfs, tenors)\n# conv_kr.base, conv_kr.credit, conv_kr.cross (all matrices)\n\n# Full two-curve sensitivities (always key-rate decomposition)\nresult = sensitivities(base, credit, cfs, tenors)\n\nThe default two-curve valuation uses multiplicative discount factors: V = Σ cf × base(t) × credit(t), which corresponds to additive rates.","category":"section"},{"location":"sensitivities/#Example:-Credit-Risky-Floating-Rate-Bond","page":"Key Rate Sensitivities","title":"Example: Credit-Risky Floating Rate Bond","text":"For fixed cashflows, IR01 and CS01 are identical because base and credit rates enter additively. A credit-risky floating rate bond breaks this symmetry — its coupons reset to the risk-free forward rate plus a fixed credit spread, so bumping base rates changes both coupon amounts and discount factors (partially canceling), while bumping credit rates only affects discounting:\n\nbase = ZeroRateCurve([0.03, 0.03, 0.03, 0.03, 0.03], tenors)\ncredit = ZeroRateCurve([0.02, 0.02, 0.02, 0.02, 0.02], tenors)\n\n# Floating rate bond: coupon = risk-free forward + 200bp credit spread\n# Discounted at the combined base + credit rate\nspread = 0.02\nface = 100.0\n\nresult = sensitivities(base, credit) do base_curve, credit_curve\n    total = 0.0\n    for t in 1:5\n        df_base = base_curve(Float64(t))\n        df_credit = credit_curve(Float64(t))\n        df_base_prev = t == 1 ? 1.0 : base_curve(Float64(t - 1))\n\n        # Coupon resets to risk-free forward rate + fixed credit spread\n        fwd = df_base_prev / df_base - 1.0\n        total += face * (fwd + spread) * df_base * df_credit\n\n        # Principal at maturity\n        t == 5 && (total += face * df_base * df_credit)\n    end\n    total\nend\n\nsum(result.base_durations)    # IR01 — small, coupon reset offsets base rate sensitivity\nsum(result.credit_durations)  # CS01 — larger, credit spread only affects discounting\n\nBumping base rates changes both the floating coupon amounts and the discount factors (partially canceling), while bumping credit rates only affects discounting. This asymmetry is why the IR01/CS01 decomposition matters for instruments with rate-dependent cashflows.","category":"section"},{"location":"sensitivities/#Portfolio-Sensitivity","page":"Key Rate Sensitivities","title":"Portfolio Sensitivity","text":"DV01s are additive across positions, so a portfolio's DV01 vector equals the sum of individual DV01s:\n\nzrc = ZeroRateCurve(rates, tenors)\n\n# Compute portfolio DV01 vector in a single AD pass\n# bond1_cfs, bond2_cfs are Vector{Cashflow} (from FinanceCore)\nportfolio_dv01 = duration(DV01(), KeyRates(), zrc) do curve\n    pv(curve, bond1_cfs) + pv(curve, bond2_cfs)\nend\n\n# Equivalently (but two AD passes):\ndv01_1 = duration(DV01(), KeyRates(), zrc, bond1_cfs, bond1_times)\ndv01_2 = duration(DV01(), KeyRates(), zrc, bond2_cfs, bond2_times)\nportfolio_dv01 ≈ dv01_1 .+ dv01_2","category":"section"},{"location":"sensitivities/#Example:-Portfolio-of-Floating-Rate-Bonds","page":"Key Rate Sensitivities","title":"Example: Portfolio of Floating Rate Bonds","text":"Floating rate bonds have coupons that reset to the prevailing market rate, so their cashflows depend on the rate curve itself. The do-block captures this dependency through AD — differentiating through both the discount factors and the coupon amounts in a single pass:\n\nusing ActuaryUtilities, FinanceModels\n\nrates = [0.02, 0.025, 0.03, 0.035, 0.04, 0.042, 0.044, 0.046, 0.048, 0.05]\ntenors = collect(1.0:10.0)\nzrc = ZeroRateCurve(rates, tenors)\n\n# 10 floating rate bonds: maturities 1yr to 10yr, face 100 each,\n# annual coupons = 1yr forward rate + 50bp credit spread\nnotionals = fill(100.0, 10)\nmaturities = 1:10\nspread = 0.005\n\n# The do-block receives the curve and returns the total present value\n# of all cashflows across the portfolio.\n# The curve is constructed once per AD evaluation — valuing all 10 bonds\n# inside a single do-block avoids rebuilding the curve for each bond.\nresult = sensitivities(zrc) do curve\n    total = 0.0\n    for (notional, mat) in zip(notionals, maturities)\n        # For each bond, loop over annual payment dates t = 1, 2, ..., maturity\n        for t in 1:mat\n            # Discount factors: df = P(0,t), df_prev = P(0,t-1)\n            df = curve(Float64(t))\n            df_prev = t == 1 ? 1.0 : curve(Float64(t - 1))\n\n            # 1yr simple forward rate from t-1 to t: F = P(0,t-1)/P(0,t) - 1\n            fwd = df_prev / df - 1.0\n\n            # Floating coupon PV: notional × (forward rate + spread) × P(0,t)\n            total += notional * (fwd + spread) * df\n\n            # Return principal at maturity\n            t == mat && (total += notional * df)\n        end\n    end\n    total\nend\n\nresult.value       # portfolio present value (≈ 10 × 100 + spread premium)\nresult.durations   # key rate durations — small, since floaters reset\n\nWithout the spread, a floater prices at par and has near-zero duration (coupons offset discount factor changes). The spread introduces duration because its fixed cashflows are rate-sensitive — similar to a portfolio of small fixed-rate annuities layered on top of the par-valued floaters.","category":"section"},{"location":"sensitivities/#Stochastic-Model-Sensitivities","page":"Key Rate Sensitivities","title":"Stochastic Model Sensitivities","text":"ForwardDiff's dual numbers propagate through the full Monte Carlo simulation pipeline in FinanceModels.jl, including the Euler-Maruyama path generation. This means you can compute exact sensitivities of expected present values under stochastic short-rate models — differentiating through thousands of simulated rate paths in a single AD pass.","category":"section"},{"location":"sensitivities/#What-is-being-differentiated?","page":"Key Rate Sensitivities","title":"What is being differentiated?","text":"The sensitivities function always differentiates with respect to the zero rates in the ZeroRateCurve — these are the market-observable inputs. When you wrap a stochastic model inside the do-block:\n\nhw = ShortRate.HullWhite(0.1, 0.01, zrc)\nsensitivities(hw, cfs, times; n_scenarios=500, rng=Xoshiro(42))\n\nthe chain of differentiation is:\n\nForwardDiff perturbs zero rate rᵢ\nThe perturbed curve changes the forward curve f(0, t)\nHull-White recalibrates θ(t) from the new forwards\nAll simulated paths shift (same random draws, different drift)\nThe expected PV changes → this change is the KRD at tenor i\n\nThe stochastic model parameters (a, σ) are not being differentiated — they are constants in this computation. The KRDs answer: \"if the market yield curve shifts, how does my model-valued portfolio respond?\" This is the relevant question for hedging with market instruments (bonds, swaps), which is the primary use case for key rate durations.","category":"section"},{"location":"sensitivities/#Model-parameter-sensitivities-(vega,-mean-reversion-sensitivity)","page":"Key Rate Sensitivities","title":"Model parameter sensitivities (vega, mean-reversion sensitivity)","text":"A separate question is: \"how does expected PV change if I change the model parameters a or σ?\" These are model risk sensitivities, useful for understanding calibration sensitivity and model uncertainty. They are conceptually different from curve KRDs:\n\n Curve KRDs (∂V/∂rᵢ) Model Greeks (∂V/∂a, ∂V/∂σ)\nWhat moves Market zero rates Model calibration parameters\nUse case Hedging with bonds/swaps Model risk, calibration stability\nHedgeable? Yes (with market instruments) No (not directly tradeable)\n\nModel parameter sensitivities (∂V/∂a, ∂V/∂σ) are not currently supported by the AD pathway. The simulate function in FinanceModels.jl uses Float64 arrays internally for simulation paths, which prevents ForwardDiff dual numbers from propagating through the model parameters. Dual numbers flow through the curve rates (because build_model and θ(t) calibration handle generic numeric types), but a and σ must be plain Float64.\n\nFor model parameter sensitivities, use finite differences as a workaround:\n\nusing FinanceModels: ShortRate, simulate\nusing FinanceCore: discount\nusing Random: Xoshiro\n\nrates = [0.03, 0.03, 0.03, 0.03, 0.03]\ntenors = [1.0, 2.0, 3.0, 4.0, 5.0]\ncfs = [5.0, 5.0, 5.0, 5.0, 105.0]\n\nfunction mc_value(a, σ)\n    curve = ZeroRateCurve(rates, tenors)\n    hw = ShortRate.HullWhite(a, σ, curve)\n    scenarios = simulate(hw; n_scenarios=1000, timestep=1/12, horizon=6.0, rng=Xoshiro(42))\n    sum(pv(sc, cfs, tenors) for sc in scenarios) / 1000\nend\n\n# Finite-difference sensitivities\nε = 1e-5\ndV_da = (mc_value(0.1 + ε, 0.01) - mc_value(0.1 - ε, 0.01)) / (2ε)   # mean reversion\ndV_dσ = (mc_value(0.1, 0.01 + ε) - mc_value(0.1, 0.01 - ε)) / (2ε)   # volatility (vega)\n\nnote: Note\nSupporting AD through model parameters would require parameterizing the element type of internal simulation arrays on the model parameter types in FinanceModels.jl. This is a potential future enhancement.","category":"section"},{"location":"sensitivities/#Hull-White:-sensitivities-w.r.t.-the-initial-term-structure","page":"Key Rate Sensitivities","title":"Hull-White: sensitivities w.r.t. the initial term structure","text":"A Hull-White model calibrates its drift θ(t) to match an initial yield curve. When that curve is a ZeroRateCurve, you can compute how the Monte Carlo expected value responds to movements in the initial zero rates:\n\nusing ActuaryUtilities, FinanceModels\nusing FinanceModels: ShortRate, simulate\nusing FinanceCore: discount\nusing Random\n\nrates = [0.03, 0.03, 0.03, 0.03, 0.03]\ntenors = [1.0, 2.0, 3.0, 4.0, 5.0]\nzrc = ZeroRateCurve(rates, tenors)\n\ncfs = [5.0, 5.0, 5.0, 5.0, 105.0]\ntimes = [1.0, 2.0, 3.0, 4.0, 5.0]\n\n# Key rate sensitivities of E[V] under Hull-White dynamics\nhw = ShortRate.HullWhite(0.1, 0.01, zrc)\nhw_result = sensitivities(hw, cfs, times; n_scenarios=500, timestep=1/12, horizon=6.0, rng=Xoshiro(42))\n\nhw_result.durations   # key rate durations under stochastic dynamics\nhw_result.convexities # cross-convexity matrix\n\nThis involves nested AD: the outer ForwardDiff differentiates w.r.t. zero rates, while Hull-White's θ(t) calibration internally uses ForwardDiff to compute instantaneous forward rates from the curve. ForwardDiff's tag system disambiguates the two differentiation passes automatically.","category":"section"},{"location":"sensitivities/#Comparison:-deterministic-vs-model-based-sensitivities","page":"Key Rate Sensitivities","title":"Comparison: deterministic vs model-based sensitivities","text":"The deterministic ZeroRateCurve and Hull-White MC valuations produce the same total duration for fixed cashflows (a consequence of the risk-neutral pricing theorem), but decompose it across tenors differently:\n\n# Deterministic: discount directly off the initial curve\ndet_result = sensitivities(zrc, cfs, tenors)\n\n# Model-based: average across simulated rate paths\nhw = ShortRate.HullWhite(0.1, 0.01, zrc)\nhw_result = sensitivities(hw, cfs, times; n_scenarios=1000, timestep=1/12, horizon=6.0, rng=Xoshiro(42))\n\ndet_result.durations  # [0.04, 0.09, 0.13, 0.16, 4.15]  (localized at each tenor)\nhw_result.durations   # [-1.01, 1.04, 1.70, 1.85, 0.99]  (redistributed across tenors)\n\nsum(det_result.durations) # 4.57  — total modified duration (= duration(zrc, cfs, tenors))\nsum(hw_result.durations)  # 4.57  — same total (risk-neutral guarantee)\n\nWhy the totals match: For fixed cashflows, E[V] = Σ cfi × P(0, ti) under any risk-neutral model (Glasserman, 2003, Ch. 7), so a parallel shift of all zero rates produces the same ΔV regardless of whether we compute it by direct discounting or via Monte Carlo. This implies Σ KRDdet = Σ KRDHW.\n\nWhy the decomposition differs: The two approaches construct discount factors through different mathematical pathways. ZeroRateCurve with linear interpolation gives df(t) = exp(-r_interp(t) × t), where bumping ratej only affects the interpolated rate near tenor j — producing localized KRDs. Hull-White constructs discount factors by integrating a calibrated short-rate ODE: bumping ratej changes the forward curve f(0,t), which changes θ(t) = ∂f/∂t + a·f + σ²(1−e^{−2at})/2a everywhere, altering the short-rate path at all times via the mean-reversion dynamics (Brigo & Mercurio, 2006, Ch. 3). This creates non-local sensitivity even in the σ→0 limit — it is the model's parametric structure, not stochastic volatility, that redistributes duration.\n\nThis phenomenon is well-established in derivatives pricing as \"model-dependent Greeks\": different models calibrated to the same curve produce identical prices but different sensitivities. The pathwise differentiation technique used here (Giles & Glasserman, 2006) computes exact derivatives of the Monte Carlo estimate in a single forward pass, capturing the full chain of dependencies from initial curve through θ(t) calibration through path simulation to valuation.\n\nnote: Note\nThe fixed rng seed ensures reproducibility: the same random draws are used for every AD perturbation, giving exact pathwise derivatives. Without a fixed seed, each call would use different paths, introducing MC noise into the gradient.","category":"section"},{"location":"sensitivities/#Choosing-Interpolation","page":"Key Rate Sensitivities","title":"Choosing Interpolation","text":"ZeroRateCurve accepts an optional third argument for the interpolation method:\n\nzrc = ZeroRateCurve(rates, tenors)                              # default: MonotoneConvex\nzrc_pchip = ZeroRateCurve(rates, tenors, Spline.PCHIP())        # PCHIP\nzrc_lin = ZeroRateCurve(rates, tenors, Spline.Linear())          # linear\nzrc_cub = ZeroRateCurve(rates, tenors, Spline.Cubic())           # cubic spline\nzrc_aki = ZeroRateCurve(rates, tenors, Spline.Akima())           # Akima\n\nMonotoneConvex (Spline.MonotoneConvex(), default): Finance-aware interpolation (Hagan & West, 2006). Guarantees positive continuous forward rates, best KRD locality among smooth methods, and fastest AD performance.\n\nPCHIP (Spline.PCHIP()): Smooth forward curves (C1), local sensitivity, monotonicity-preserving. Good general-purpose alternative.\n\nLinear (Spline.Linear()): Perfectly local KRDs (zero sensitivity outside adjacent intervals), but kinks in the forward curve at tenor points.\n\nAkima (Spline.Akima()): Alternative to PCHIP with different behavior near inflection points. Slightly more non-local leakage than PCHIP.\n\nCubic spline (Spline.Cubic()): Smoothest (C2), but bumps have non-local effects. KRDs at distant tenors may be negative. Use when smoothness matters most.\n\nSee the FinanceModels interpolation guide for detailed benchmarks and tradeoff analysis. On a flat curve, all methods produce identical results.","category":"section"},{"location":"sensitivities/#Validating-AD-vs-Bump-and-Reprice","page":"Key Rate Sensitivities","title":"Validating AD vs Bump-and-Reprice","text":"AD sensitivities can be cross-validated against traditional finite-difference (bump-and-reprice) results. The AD approach gives exact derivatives in a single pass, while FD has O(ε²) truncation error:\n\nusing ActuaryUtilities, FinanceModels, Test\n\nrates = [0.02, 0.03, 0.04, 0.05]\ntenors = [1.0, 3.0, 5.0, 10.0]\nzrc = ZeroRateCurve(rates, tenors)\ncfs = [3.0, 3.0, 3.0, 103.0]\n\n# AD (exact) — use KeyRates() for the per-tenor vector\nad_dv01 = duration(DV01(), KeyRates(), zrc, cfs, tenors)\n\n# Finite difference (bump-and-reprice)\nε = 1e-5\nfor i in 1:4\n    rates_up = copy(rates); rates_up[i] += ε\n    rates_dn = copy(rates); rates_dn[i] -= ε\n    v_up = pv(ZeroRateCurve(rates_up, tenors), cfs, tenors)\n    v_dn = pv(ZeroRateCurve(rates_dn, tenors), cfs, tenors)\n    fd_dv01 = -(v_up - v_dn) / (2ε) / 10_000\n    @test ad_dv01[i] ≈ fd_dv01 atol = 1e-4\nend","category":"section"},{"location":"API/ActuaryUtilities/#ActuaryUtilities-API-Reference","page":"ActuaryUtilities","title":"ActuaryUtilities API Reference","text":"Modules = [ActuaryUtilities]","category":"section"},{"location":"API/ActuaryUtilities/#Exported-API","page":"ActuaryUtilities","title":"Exported API","text":"","category":"section"},{"location":"API/ActuaryUtilities/#Unexported-API","page":"ActuaryUtilities","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"financial_math/#Financial-Math-Submodule","page":"Financial Math","title":"Financial Math Submodule","text":"Provides a set of common routines in financial maths.","category":"section"},{"location":"financial_math/#Quickstart","page":"Financial Math","title":"Quickstart","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"section"},{"location":"financial_math/#API","page":"Financial Math","title":"API","text":"","category":"section"},{"location":"financial_math/#Exported-API","page":"Financial Math","title":"Exported API","text":"","category":"section"},{"location":"financial_math/#Unexported-API","page":"Financial Math","title":"Unexported API","text":"","category":"section"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.CS01","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.CS01","text":"CS01 <: Duration\n\nCredit Spread 01. The dollar change in value for a 1 basis point parallel shift in the credit spread, holding the risk-free (base) curve constant.\n\nRequires both a base curve and credit spread to be specified. For a flat additive decomposition, CS01 ≈ IR01 ≈ DV01.\n\nSee also: IR01, DV01\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.DV01","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.DV01","text":"DV01 <: Duration\n\nDollar Value of 01. The dollar change in value for a 1 basis point (0.01%) parallel shift in rates.\n\nDV01 = -∂V/∂r / 10000, so a DV01 of 0.045 means the position loses 0.045 per 100 notional for a 1bp rate increase.\n\nSee also: IR01, CS01\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.IR01","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.IR01","text":"IR01 <: Duration\n\nInterest Rate 01. The dollar change in value for a 1 basis point parallel shift in the risk-free (base) curve, holding the credit spread constant.\n\nRequires both a base curve and credit spread to be specified. For a flat additive decomposition, IR01 ≈ CS01 ≈ DV01.\n\nSee also: CS01, DV01\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRate","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRate","text":"KeyRate(timepoints,shift=0.001)\n\nA convenience constructor for KeyRateZero. \n\nExtended Help\n\nKeyRateZero is chosen as the default constructor because it has more attractive properties than KeyRatePar:\n\nrates after the key timepoint remain unaffected by the shift\ne.g. this causes a 6-year zero coupon bond would have a negative duration if the 5-year par rate was used\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRatePar","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRatePar","text":"KeyRatePar(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration. \n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDurations are computed via a shift-and-compute the yield curve approach.\n\nKeyRatePar is more commonly reported (than KeyRateZero) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRateZero","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRateZero","text":"KeyRateZero(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration.\n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDuration is computed via a shift-and-compute the yield curve approach.\n\nKeyRateZero is less commonly reported (than KeyRatePar) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRates","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRates","text":"KeyRates <: Duration\n\nDispatch type that requests the full key-rate decomposition (vector of durations or matrix of convexities) instead of the default scalar summary.\n\nUse with duration and convexity when a ZeroRateCurve is the rate input:\n\nduration(KeyRates(), zrc, cfs, times)            # vector of key rate durations\nduration(DV01(), KeyRates(), zrc, cfs, times)     # vector of key rate DV01s\nconvexity(KeyRates(), zrc, cfs, times)            # matrix of key rate convexities\n\nWithout KeyRates(), these functions return a scalar (the sum of the decomposition).\n\nSee also: DV01, IR01, CS01\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.breakeven","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.breakeven","text":"breakeven(yield, cashflows::Vector)\nbreakeven(yield, cashflows::Vector,times::Vector)\n\nCalculate the time when the accumulated cashflows breakeven given the yield.\n\nAssumptions:\n\ncashflows occur at the end of the period\ncashflows evenly spaced with the first one occuring at time zero if times not given\n\nReturns nothing if cashflow stream never breaks even.\n\njulia> breakeven(0.10, [-10,1,2,3,4,8])\n5\n\njulia> breakeven(0.10, [-10,15,2,3,4,8])\n1\n\njulia> breakeven(0.10, [-10,-15,2,3,4,8]) # returns the `nothing` value\n\n\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{Any, Any, Any}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(yield,cfs,times)\nconvexity(yield,valuation_function)\n\nCalculates the convexity.     - yield should be a fixed effective yield (e.g. 0.05).     - times may be omitted and it will assume cfs are evenly spaced beginning at the end of the first period.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5\njulia> cfs = [0,0,0,0,100]\njulia> duration(0.03,cfs,times)\n4.854368932038834\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> NamedTuple of scalars\n\nCompute scalar two-curve convexity. Returns a NamedTuple with scalar base, credit, and cross values (sums of the corresponding key rate matrices).\n\nFor the full key-rate decomposition (matrices), use KeyRates().\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(zrc::ZeroRateCurve, cfs, times) -> scalar\nconvexity(valuation_fn::Function, zrc::ZeroRateCurve) -> scalar\n\nCompute the scalar convexity for a ZeroRateCurve: the sum of all elements of the key rate convexity matrix.\n\nFor the full key-rate decomposition (a matrix), use KeyRates():\n\nconvexity(KeyRates(), zrc, cfs, times)   # matrix\nconvexity(zrc, cfs, times)               # scalar (≡ sum of above)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{KeyRates, Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(::KeyRates, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> NamedTuple of matrices\n\nCompute two-curve convexity. Returns a NamedTuple with base, credit, and cross matrices.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{KeyRates, Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(::KeyRates, zrc::ZeroRateCurve, cfs, times) -> Matrix\nconvexity(::KeyRates, valuation_fn::Function, zrc::ZeroRateCurve) -> Matrix\n\nCompute key rate convexity matrix: ∂²V/∂rᵢ∂rⱼ / V.\n\nExamples\n\nusing FinanceModels\nzrc = ZeroRateCurve([0.03, 0.03, 0.03], [1.0, 2.0, 3.0])\n\n# Key rate convexity matrix\nconv = convexity(KeyRates(), zrc, [5.0, 5.0, 105.0], [1.0, 2.0, 3.0])\n\n# Scalar convexity\nconvexity(zrc, [5.0, 5.0, 105.0], [1.0, 2.0, 3.0])   # ≡ sum(conv)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.moic-Tuple{T} where T<:AbstractArray","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.moic","text":"moic(cashflows<:AbstractArray)\n\nThe multiple on invested capital (\"moic\") is the un-discounted sum of distributions divided by the sum of the contributions. The function assumes that negative numbers in the array represent contributions and positive numbers represent distributions.\n\nExamples\n\njulia> moic([-10,20,30])\n5.0\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.present_values","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.present_values","text":"present_values(interest, cashflows, timepoints)\n\nEfficiently calculate a vector representing the present value of the given cashflows at each period prior to the given timepoint.\n\nExamples\n\njulia> present_values(0.00, [1,1,1])\n[3,2,1]\n\njulia> present_values(ForwardYield([0.1,0.2]), [10,20],[0,1]) # after `using FinanceModels`\n2-element Vector{Float64}:\n 28.18181818181818\n 18.18181818181818\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.price-Tuple{Any, Any}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.price","text":"price(...)\n\nThe absolute value of the present_value(...). \n\nExtended help\n\nUsing price can be helpful if the directionality of the value doesn't matter. For example, in the common usage, duration is more interested in the change in price than present value, so price is used there.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.sensitivities-Tuple{Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.sensitivities","text":"sensitivities(valuation_fn, base::ZeroRateCurve, credit::ZeroRateCurve)\nsensitivities(base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times)\nsensitivities(base::ZeroRateCurve, credit::ZeroRateCurve, cfs::AbstractVector{<:Cashflow})\n\nTwo-curve sensitivities. Returns base/credit durations and convexity matrices.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically.\n\nFor DV01s instead of durations, use sensitivities(DV01(), base, credit, cfs, times).\n\nThe convexities.cross matrix [i,j] = ∂²V/(∂base_rᵢ ∂credit_rⱼ) / V captures interaction effects between base and credit rate movements — relevant when the two curves move in correlated fashion (e.g., both driven by macro factors).\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.sensitivities-Tuple{Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.sensitivities","text":"sensitivities(zrc::ZeroRateCurve, valuation_fn::Function)\nsensitivities(zrc::ZeroRateCurve, cfs, times)\nsensitivities(zrc::ZeroRateCurve, cfs::AbstractVector{<:Cashflow})\n\nCompute value, key rate durations, and convexity matrix in a single efficient AD pass.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically.\n\nAlways returns the full key-rate decomposition (vectors and matrices), equivalent to the KeyRates() dispatch of duration and convexity. Use duration(zrc, ...) or convexity(zrc, ...) directly if you only need scalar summaries.\n\nReturns a NamedTuple with:\n\nvalue: the scalar present value\ndurations: modified key rate durations (-∂V/∂rᵢ / V) — vector\nconvexities: cross-convexity matrix (∂²V/∂rᵢ∂rⱼ / V) — matrix\n\nFor DV01s instead of durations, use sensitivities(DV01(), zrc, cfs, times).\n\nSupports do-block syntax:\n\nusing FinanceModels\nzrc = ZeroRateCurve([0.03, 0.03, 0.03], [1.0, 2.0, 3.0])\nresult = sensitivities(zrc) do curve\n    sum(cf * curve(t) for (cf, t) in zip([5.0, 5.0, 105.0], [1.0, 2.0, 3.0]))\nend\n\nWhen using stochastic (Monte Carlo) valuations, you must fix the RNG seed so that the same random draws are used for every AD perturbation:\n\nresult = sensitivities(zrc) do curve\n    hw = HullWhite(0.1, 0.01, curve)\n    pv_mc(hw, contract; n_scenarios=1000, rng=MersenneTwister(42))\nend\n\nWithout a fixed seed, gradients will be noisy and incorrect.\n\nPathwise AD is invalid for discontinuous payoffs (digital options, barriers). For those cases, use finite differences instead.\n\nTo obtain traditional scalar sensitivities from the results, sum the vector/matrix fields:\n\nresult = sensitivities(zrc, cfs, [1.0, 2.0, 3.0])\nsum(result.durations)    # scalar modified duration\nsum(result.convexities)  # scalar convexity\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.spread","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.spread","text":"spread(curve1,curve2,cashflows)\n\nReturn the solved-for constant spread to add to curve1 in order to equate the discounted cashflows with curve2\n\nExamples\n\nspread(0.04, 0.05, cfs)\nRate{Float64, Periodic}(0.010000000000000009, Periodic(1))\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{ActuaryUtilities.FinancialMath.KeyRateDuration, Vararg{Any, 4}}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any FinanceModels.jl curve (e.g. does not have to be a curve constructed via FinanceModels.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = FinanceModels.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{CS01, Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::CS01, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> scalar\n\nCompute scalar CS01 for a two-curve valuation. For key-rate decomposition, use KeyRates().\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{CS01, KeyRates, Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::CS01, ::KeyRates, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> Vector\n\nCompute key rate DV01s for the credit spread curve: -∂V/∂credit_rᵢ / 10000.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{CS01, Vararg{Any, 4}}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(CS01(), base_curve, credit_spread, cfs, times)\nduration(CS01(), base_curve, credit_spread, cfs)\n\nCalculate the CS01 (Credit Spread 01): the dollar change in value for a 1 basis point parallel shift in the credit spread, holding the risk-free (base) curve constant.\n\nThe total discount rate is assumed to be base_curve + credit_spread. For a flat additive decomposition (e.g. scalar rates), CS01 ≈ IR01 ≈ DV01.\n\nExamples\n\njulia> cfs = [5, 5, 5, 105];\n\njulia> times = 1:4;\n\njulia> duration(CS01(), 0.03, 0.02, cfs, times)\n0.03465054893498076\n\njulia> duration(CS01(), 0.03, 0.02, cfs, times) ≈ duration(DV01(), 0.05, cfs, times)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{DV01, Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::DV01, zrc::ZeroRateCurve, cfs, times) -> scalar\nduration(::DV01, valuation_fn::Function, zrc::ZeroRateCurve) -> scalar\n\nCompute the scalar DV01 for a ZeroRateCurve: the sum of all key rate DV01s.\n\nFor the full key-rate decomposition (a vector), use KeyRates():\n\nduration(DV01(), KeyRates(), zrc, cfs, times)   # vector\nduration(DV01(), zrc, cfs, times)                # scalar (≡ sum of above)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{DV01, KeyRates, Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::DV01, ::KeyRates, zrc::ZeroRateCurve, cfs, times) -> Vector\nduration(::DV01, ::KeyRates, valuation_fn::Function, zrc::ZeroRateCurve) -> Vector\n\nCompute key rate DV01s as a vector: -∂V/∂rᵢ / 10000 for each tenor.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(zrc::ZeroRateCurve, cfs, times) -> scalar\nduration(zrc::ZeroRateCurve, cfs::AbstractVector{<:Cashflow}) -> scalar\nduration(valuation_fn::Function, zrc::ZeroRateCurve) -> scalar\n\nCompute the scalar modified duration for a ZeroRateCurve: the sum of all key rate durations.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically.\n\nFor the full key-rate decomposition (a vector), use KeyRates():\n\nduration(KeyRates(), zrc, cfs, times)   # vector\nduration(zrc, cfs, times)               # scalar (≡ sum of above)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{IR01, Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::IR01, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> scalar\n\nCompute scalar IR01 for a two-curve valuation. For key-rate decomposition, use KeyRates().\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{IR01, KeyRates, Function, FinanceModels.Yield.ZeroRateCurve, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::IR01, ::KeyRates, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> Vector\n\nCompute key rate DV01s for the base (risk-free) curve: -∂V/∂base_rᵢ / 10000.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{IR01, Vararg{Any, 4}}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(IR01(), base_curve, credit_spread, cfs, times)\nduration(IR01(), base_curve, credit_spread, cfs)\n\nCalculate the IR01 (Interest Rate 01): the dollar change in value for a 1 basis point parallel shift in the risk-free (base) curve, holding the credit spread constant.\n\nThe total discount rate is assumed to be base_curve + credit_spread. For a flat additive decomposition (e.g. scalar rates), IR01 ≈ CS01 ≈ DV01.\n\nExamples\n\njulia> cfs = [5, 5, 5, 105];\n\njulia> times = 1:4;\n\njulia> duration(IR01(), 0.03, 0.02, cfs, times)\n0.03465054893498076\n\njulia> duration(IR01(), 0.03, 0.02, cfs, times) ≈ duration(DV01(), 0.05, cfs, times)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{KeyRates, Function, FinanceModels.Yield.ZeroRateCurve}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(::KeyRates, zrc::ZeroRateCurve, cfs, times) -> Vector\nduration(::KeyRates, zrc::ZeroRateCurve, cfs::AbstractVector{<:Cashflow}) -> Vector\nduration(::KeyRates, valuation_fn::Function, zrc::ZeroRateCurve) -> Vector\n\nCompute key rate durations (modified) as a vector: -∂V/∂rᵢ / V for each tenor.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically. When called with a function, it receives a curve and returns a scalar value (do-block syntax).\n\nExamples\n\nusing FinanceModels, FinanceCore\nzrc = ZeroRateCurve([0.03, 0.03, 0.03], [1.0, 2.0, 3.0])\ncfs = [5.0, 5.0, 105.0]\n\n# Key rate durations (vector)\nkrds = duration(KeyRates(), zrc, cfs, [1.0, 2.0, 3.0])\n\n# Using Cashflow objects directly\ncashflows = Cashflow.([5.0, 5.0, 105.0], [1.0, 2.0, 3.0])\nkrds = duration(KeyRates(), zrc, cashflows)\n\n# Scalar modified duration\nduration(zrc, cfs, [1.0, 2.0, 3.0])   # ≡ sum(krds)\n\n# Do-block for custom valuation\nkrds = duration(KeyRates(), zrc) do curve\n    sum(cf * curve(t) for (cf, t) in zip(cfs, [1.0, 2.0, 3.0]))\nend\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{Macaulay, Any, Any, Any}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(IR01(),base_curve,credit_spread,cfs,times)\nduration(CS01(),base_curve,credit_spread,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, DV01, IR01, or CS01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\ncfs can be an AbstractVector{<:Cashflow} (from FinanceCore), in which case times is extracted automatically and should be omitted.\n\nNote that the calculated duration will depend on the periodicity convention of the interest_rate: a Periodic yield (or yield model with that convention) will be a slightly different computed duration than a Continous which follows from the present value differing according to the periodicity.\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nModified duration: the relative change per point of yield change.\nMacaulay: the cashflow-weighted average time.\nDV01: the absolute change per basis point (hundredth of a percentage point).\nIR01: the absolute change per basis point shift in the risk-free (base) curve, holding credit spread constant.\nCS01: the absolute change per basis point shift in the credit spread, holding the risk-free (base) curve constant.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5;\n\njulia> cfs = [0,0,0,0,100];\n\njulia> duration(0.03,cfs,times)\n4.854368932038835\n\njulia> duration(Periodic(0.03,1),cfs,times)\n4.854368932038835\n\njulia> duration(Continuous(0.03),cfs,times)\n5.0\n\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\n\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\n\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"upgrade/#Version-Upgrade-Guide","page":"Upgrade from Prior Versions","title":"Version Upgrade Guide","text":"","category":"section"},{"location":"upgrade/#v3-to-v4","page":"Upgrade from Prior Versions","title":"v3 to v4","text":"","category":"section"},{"location":"upgrade/#Overview","page":"Upgrade from Prior Versions","title":"Overview","text":"The shape and API of the package is mostly unchanged. The changes that have made fall into a few categores:\n\nAccommodating FinanceModels.jl, the next-generation version of Yields.jl.\nSimplifying the API, generally making function calls require more specific arguments to avoid ambiguity\nAccommodating the new Cashflow type which makes modeling heterogeneous assets and liabilities simpler.","category":"section"},{"location":"upgrade/#API-Changes","page":"Upgrade from Prior Versions","title":"API Changes","text":"Breaking: The functions europut and eurocall have been moved to FinanceModels\nBreaking: Previously, the first argument to present_value or present_values would be interpreted as a set of Periodic(1) one-period forward rates if a vector of real values was passed. Users should explicitly create the yield model first, instead of relying on the implicit conversion:\n\n# old \npv([0.05,0.1], cfs)  \n\n# new\nusing FinanceModels\ny = fit(Spline.Linear(),ForwardYields([0.05,0.1]),Bootstrap())\npv(y,cfs)\n","category":"section"},{"location":"utilities/#Utilities-submodule","page":"Other Utilities","title":"Utilities submodule","text":"Provides miscellaneous routines common in actuarial and financial work.","category":"section"},{"location":"utilities/#API","page":"Other Utilities","title":"API","text":"","category":"section"},{"location":"utilities/#Exported-API","page":"Other Utilities","title":"Exported API","text":"","category":"section"},{"location":"utilities/#ActuaryUtilities.duration","page":"Other Utilities","title":"ActuaryUtilities.duration","text":"duration(d1::Date, d2::Date)\n\nCompute the duration given two dates, which is the number of years since the first date. The interval [0,1) is defined as having  duration 1. Can return negative durations if second argument is before the first.\n\njulia> issue_date  = Date(2018,9,30);\n\njulia> duration(issue_date , Date(2019,9,30) ) \n2\njulia> duration(issue_date , issue_date) \n1\njulia> duration(issue_date , Date(2018,10,1) ) \n1\njulia> duration(issue_date , Date(2019,10,1) ) \n2\njulia> duration(issue_date , Date(2018,6,30) ) \n0\njulia> duration(Date(2018,9,30),Date(2017,6,30)) \n-1\n\n\n\n\n\nduration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(IR01(),base_curve,credit_spread,cfs,times)\nduration(CS01(),base_curve,credit_spread,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, DV01, IR01, or CS01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\ncfs can be an AbstractVector{<:Cashflow} (from FinanceCore), in which case times is extracted automatically and should be omitted.\n\nNote that the calculated duration will depend on the periodicity convention of the interest_rate: a Periodic yield (or yield model with that convention) will be a slightly different computed duration than a Continous which follows from the present value differing according to the periodicity.\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nModified duration: the relative change per point of yield change.\nMacaulay: the cashflow-weighted average time.\nDV01: the absolute change per basis point (hundredth of a percentage point).\nIR01: the absolute change per basis point shift in the risk-free (base) curve, holding credit spread constant.\nCS01: the absolute change per basis point shift in the credit spread, holding the risk-free (base) curve constant.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5;\n\njulia> cfs = [0,0,0,0,100];\n\njulia> duration(0.03,cfs,times)\n4.854368932038835\n\njulia> duration(Periodic(0.03,1),cfs,times)\n4.854368932038835\n\njulia> duration(Continuous(0.03),cfs,times)\n5.0\n\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\n\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\n\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\nduration(IR01(), base_curve, credit_spread, cfs, times)\nduration(IR01(), base_curve, credit_spread, cfs)\n\nCalculate the IR01 (Interest Rate 01): the dollar change in value for a 1 basis point parallel shift in the risk-free (base) curve, holding the credit spread constant.\n\nThe total discount rate is assumed to be base_curve + credit_spread. For a flat additive decomposition (e.g. scalar rates), IR01 ≈ CS01 ≈ DV01.\n\nExamples\n\njulia> cfs = [5, 5, 5, 105];\n\njulia> times = 1:4;\n\njulia> duration(IR01(), 0.03, 0.02, cfs, times)\n0.03465054893498076\n\njulia> duration(IR01(), 0.03, 0.02, cfs, times) ≈ duration(DV01(), 0.05, cfs, times)\ntrue\n\n\n\n\n\nduration(CS01(), base_curve, credit_spread, cfs, times)\nduration(CS01(), base_curve, credit_spread, cfs)\n\nCalculate the CS01 (Credit Spread 01): the dollar change in value for a 1 basis point parallel shift in the credit spread, holding the risk-free (base) curve constant.\n\nThe total discount rate is assumed to be base_curve + credit_spread. For a flat additive decomposition (e.g. scalar rates), CS01 ≈ IR01 ≈ DV01.\n\nExamples\n\njulia> cfs = [5, 5, 5, 105];\n\njulia> times = 1:4;\n\njulia> duration(CS01(), 0.03, 0.02, cfs, times)\n0.03465054893498076\n\njulia> duration(CS01(), 0.03, 0.02, cfs, times) ≈ duration(DV01(), 0.05, cfs, times)\ntrue\n\n\n\n\n\nduration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any FinanceModels.jl curve (e.g. does not have to be a curve constructed via FinanceModels.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = FinanceModels.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\nduration(zrc::ZeroRateCurve, cfs, times) -> scalar\nduration(zrc::ZeroRateCurve, cfs::AbstractVector{<:Cashflow}) -> scalar\nduration(valuation_fn::Function, zrc::ZeroRateCurve) -> scalar\n\nCompute the scalar modified duration for a ZeroRateCurve: the sum of all key rate durations.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically.\n\nFor the full key-rate decomposition (a vector), use KeyRates():\n\nduration(KeyRates(), zrc, cfs, times)   # vector\nduration(zrc, cfs, times)               # scalar (≡ sum of above)\n\n\n\n\n\nduration(::KeyRates, zrc::ZeroRateCurve, cfs, times) -> Vector\nduration(::KeyRates, zrc::ZeroRateCurve, cfs::AbstractVector{<:Cashflow}) -> Vector\nduration(::KeyRates, valuation_fn::Function, zrc::ZeroRateCurve) -> Vector\n\nCompute key rate durations (modified) as a vector: -∂V/∂rᵢ / V for each tenor.\n\ncfs can be an AbstractVector{<:Cashflow}, in which case times is extracted automatically. When called with a function, it receives a curve and returns a scalar value (do-block syntax).\n\nExamples\n\nusing FinanceModels, FinanceCore\nzrc = ZeroRateCurve([0.03, 0.03, 0.03], [1.0, 2.0, 3.0])\ncfs = [5.0, 5.0, 105.0]\n\n# Key rate durations (vector)\nkrds = duration(KeyRates(), zrc, cfs, [1.0, 2.0, 3.0])\n\n# Using Cashflow objects directly\ncashflows = Cashflow.([5.0, 5.0, 105.0], [1.0, 2.0, 3.0])\nkrds = duration(KeyRates(), zrc, cashflows)\n\n# Scalar modified duration\nduration(zrc, cfs, [1.0, 2.0, 3.0])   # ≡ sum(krds)\n\n# Do-block for custom valuation\nkrds = duration(KeyRates(), zrc) do curve\n    sum(cf * curve(t) for (cf, t) in zip(cfs, [1.0, 2.0, 3.0]))\nend\n\n\n\n\n\nduration(::DV01, zrc::ZeroRateCurve, cfs, times) -> scalar\nduration(::DV01, valuation_fn::Function, zrc::ZeroRateCurve) -> scalar\n\nCompute the scalar DV01 for a ZeroRateCurve: the sum of all key rate DV01s.\n\nFor the full key-rate decomposition (a vector), use KeyRates():\n\nduration(DV01(), KeyRates(), zrc, cfs, times)   # vector\nduration(DV01(), zrc, cfs, times)                # scalar (≡ sum of above)\n\n\n\n\n\nduration(::DV01, ::KeyRates, zrc::ZeroRateCurve, cfs, times) -> Vector\nduration(::DV01, ::KeyRates, valuation_fn::Function, zrc::ZeroRateCurve) -> Vector\n\nCompute key rate DV01s as a vector: -∂V/∂rᵢ / 10000 for each tenor.\n\n\n\n\n\nduration(::IR01, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> scalar\n\nCompute scalar IR01 for a two-curve valuation. For key-rate decomposition, use KeyRates().\n\n\n\n\n\nduration(::IR01, ::KeyRates, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> Vector\n\nCompute key rate DV01s for the base (risk-free) curve: -∂V/∂base_rᵢ / 10000.\n\n\n\n\n\nduration(::CS01, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> scalar\n\nCompute scalar CS01 for a two-curve valuation. For key-rate decomposition, use KeyRates().\n\n\n\n\n\nduration(::CS01, ::KeyRates, base::ZeroRateCurve, credit::ZeroRateCurve, cfs, times) -> Vector\n\nCompute key rate DV01s for the credit spread curve: -∂V/∂credit_rᵢ / 10000.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ActuaryUtilities.Utilities.years_between","page":"Other Utilities","title":"ActuaryUtilities.Utilities.years_between","text":"Years_Between(d1::Date, d2::Date)\n\nCompute the number of integer years between two dates, with the  first date typically before the second. Will return negative number if first date is after the second. Use third argument to indicate if calendar  anniversary should count as a full year.\n\nExamples\n\njulia> d1 = Date(2018,09,30);\n\njulia> d2 = Date(2019,09,30);\n\njulia> d3 = Date(2019,10,01);\n\njulia> years_between(d1,d3) \n1\njulia> years_between(d1,d2,false) # same month/day but `false` overlap\n0 \njulia> years_between(d1,d2) # same month/day but `true` overlap\n1 \njulia> years_between(d1,d2) # using default `true` overlap\n1 \n\n\n\n\n\n","category":"function"},{"location":"utilities/#ActuaryUtilities.Utilities.accum_offset","page":"Other Utilities","title":"ActuaryUtilities.Utilities.accum_offset","text":"accum_offset(x; op=*, init=1.0)\n\nA shortcut for the common operation wherein a vector is scanned with an operation, but has an initial value and the resulting array is offset from the traditional accumulate. \n\nThis is a common pattern when calculating things like survivorship given a mortality vector and you want the first value of the resulting vector to be 1.0, and the second value to be 1.0 * x[1], etc.\n\nTwo keyword arguments:\n\nop is the binary (two argument) operator you want to use, such as * or +\ninit is the initial value in the returned array\n\nExamples\n\njulia> accum_offset([0.9, 0.8, 0.7])\n3-element Array{Float64,1}:\n 1.0\n 0.9\n 0.7200000000000001\n\njulia> accum_offset(1:5) # the product of elements 1:n, with the default `1` as the first value\n5-element Array{Int64,1}:\n  1\n  1\n  2\n  6\n 24\n\njulia> accum_offset(1:5,op=+)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  7\n 11\n\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore (re-exported)","title":"FinanceCore API Reference","text":"Modules = [FinanceCore]","category":"section"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore (re-exported)","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore (re-exported)","title":"Unexported API","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"section"},{"location":"API/FinanceCore/#FinanceCore.Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.Cashflow","text":"Cashflow(amount,time)\n\nA Cahflow{A,B} is a contract that pays an amount at time. \n\nCashflows can be:\n\nnegated with the unary - operator. \nadded/subtracted together but note that the time must be isapprox equal.\nmultiplied/divided by a scalar.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nCashflow{A<:Real, B<:Timepoint} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore (re-exported)","title":"FinanceCore.Composite","text":"Composite(A,B)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore (re-exported)","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nUse rate to retrieve the nominal rate value from a Rate with Continuous compounding.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nContinuous(0.01)\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Continuous","text":"Continuous(rate)\n\nA convenience constructor for Rate(rate, Continuous()). Use rate to retrieve the nominal rate value.\n\njulia> Continuous(0.01)\nContinuous(0.01)\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore (re-exported)","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency.\n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError).\n\nUse rate to retrieve the nominal rate value from a Rate with Periodic compounding.\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nPeriodic(0.01, 2)\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Periodic","text":"Periodic(rate, frequency)\n\nA convenience constructor for Rate(rate, Periodic(frequency)). Use rate to retrieve the nominal rate value.\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nPeriodic(0.01, 2)\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore (re-exported)","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nInternally, all rates (including Periodic rates) are stored as their continuously compounded equivalent for performance. This means the internal field values will differ from the nominal rate. Use rate to retrieve the nominal rate value corresponding to the compounding frequency, and compounding to retrieve the compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nContinuous(0.01)\n\njulia> Continuous(0.01)\nContinuous(0.01)\n\njulia> Continuous()(0.01)\nContinuous(0.01)\n\njulia> Rate(0.01,Periodic(2))\nPeriodic(0.01, 2)\n\njulia> Periodic(0.01,2)\nPeriodic(0.01, 2)\n\njulia> Periodic(2)(0.01)\nPeriodic(0.01, 2)\n\njulia> Rate(0.01)\nPeriodic(0.01, 1)\n\njulia> Rate(0.01,2)\nPeriodic(0.01, 2)\n\njulia> Rate(0.01,Periodic(4))\nPeriodic(0.01, 4)\n\njulia> Rate(0.01,Inf)\nContinuous(0.01)\n\njulia> rate(Periodic(0.01,2))\n0.01\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.accumulation-Tuple{Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.accumulation","text":"accumulation(rate, t)\naccumulation(rate, from, to)\n\nAccumulate rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\n# Examples\n\njulia> accumulation(0.03, 10)\n1.3439163793441222\n\njulia> accumulation(Periodic(0.03, 2), 10)\n1.3468550065500535\n\njulia> accumulation(Continuous(0.03), 10)\n1.3498588075760032\n\njulia> accumulation(0.03, 5, 10)\n1.1592740743\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.compounding-Tuple{Rate}","page":"FinanceCore (re-exported)","title":"FinanceCore.compounding","text":"compounding(r::Rate)\n\nReturns the compounding frequency of the Rate.\n\nExamples\n\njulia> r = Continuous(0.03)\nContinuous(0.03)\n\njulia> compounding(r)\nContinuous()\n\njulia> r = Periodic(0.05, 2)\nPeriodic(0.05, 2)\n\njulia> compounding(r)\nPeriodic(2)\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.discount-Tuple{Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.discount","text":"discount(rate, t)\ndiscount(rate, from, to)\n\nDiscount rate for a time t or for an interval (from, to). If rate is not a Rate, it will be assumed to be a Periodic rate compounded once per period, i.e. Periodic(rate,1). \n\nExamples\n\njulia> discount(0.03, 10)\n0.7440939148967249\n\njulia> discount(Periodic(0.03, 2), 10)\n0.7424704182237725\n\njulia> discount(Continuous(0.03), 10)\n0.7408182206817179\n\njulia> discount(0.03, 5, 10)\n0.8626087843841639\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{AbstractVector{<:Real}}","page":"FinanceCore (re-exported)","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore (re-exported)","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate{<:Any, Continuous}}","page":"FinanceCore (re-exported)","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the nominal (untyped scalar) interest rate represented by the Rate, corresponding to its compounding frequency.\n\nSince Rate internally stores all rates (including Periodic) as their continuously compounded equivalent for performance, rate recovers the nominal rate for the given compounding convention.\n\nExamples\n\njulia> r = Continuous(0.03)\nContinuous(0.03)\n\njulia> rate(r)\n0.03\n\njulia> r = Periodic(0.06, 2)\nPeriodic(0.06, 2)\n\njulia> rate(r)\n0.06\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Timepoint","page":"FinanceCore (re-exported)","title":"FinanceCore.Timepoint","text":"Timepoint(a)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nTimepoint is a type alias for Union{T,Dates.Date} that can be used to represent a point in time. It can be either a Dates.Date or a Real number. If defined as a real number, the interpretation is the number of (fractional) periods since time zero.\n\nCurrently, the usage of Dates.Date is not well supported across the JuliaActuary ecosystem but this type is in place such that it can be built upon further.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nTimepoint{T} = Union{T,Dates.Date} <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore (re-exported)","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"section"},{"location":"#Features","page":"Overview","title":"Features","text":"A collection of common functions/manipulations used in Actuarial Calculations.","category":"section"},{"location":"#Financial-Maths","page":"Overview","title":"Financial Maths","text":"duration:\nCalculate the Macaulay, Modified, or DV01 durations for a set of cashflows\nCalculate the KeyRate(time) (a.k.a. KeyRateZero) duration or KeyRatePar(time) duration\nconvexity for price sensitivity\nFlexible interest rate models via the FinanceModels.jl package.\ninternal_rate_of_return or irr to calculate the IRR given cashflows (including at timepoints like Excel's XIRR)\nbreakeven to calculate the breakeven time for a set of cashflows\naccum_offset to calculate accumulations like survivorship from a mortality vector\nspread will calculate the spread needed between two yield curves to equate a set of cashflows","category":"section"},{"location":"#Key-Rate-Sensitivities-via-Automatic-Differentiation","page":"Overview","title":"Key Rate Sensitivities via Automatic Differentiation","text":"Compute exact key rate durations, DV01s, and convexities using ForwardDiff through ZeroRateCurve from FinanceModels.jl – machine-precision sensitivities in a single pass, no bump-and-reprice required.\n\nusing ActuaryUtilities, FinanceModels\n\nrates = [0.03, 0.03, 0.03, 0.03, 0.03]\ntenors = [1.0, 2.0, 3.0, 4.0, 5.0]\nzrc = ZeroRateCurve(rates, tenors)\ncfs = [5.0, 5.0, 5.0, 5.0, 105.0]\n\n# All key rate sensitivities in one AD pass\nresult = sensitivities(zrc, cfs, tenors)\nresult.value       # present value\nresult.durations   # key rate durations (vector)\nresult.convexities # cross-convexity matrix\n\nsensitivities: bundled value, key rate durations, and convexity matrix in a single AD pass\nTwo-curve decomposition: separate IR01 (risk-free) and CS01 (credit spread) sensitivities\nDo-block syntax: custom valuation functions for rate-dependent instruments (callable bonds, floaters, caps/floors)\nHull-White stochastic model: key rate sensitivities of Monte Carlo expected values, differentiating through the full simulation pipeline\n\nusing FinanceModels: ShortRate\n\nhw = ShortRate.HullWhite(0.1, 0.01, zrc)\nhw_result = sensitivities(hw, cfs, tenors; n_scenarios=1000, rng=Xoshiro(42))\nhw_result.durations   # key rate durations under stochastic dynamics\n\nSee the Key Rate Sensitivities documentation for details.","category":"section"},{"location":"#Risk-Measures","page":"Overview","title":"Risk Measures","text":"Calculate risk measures for a given vector of risks:\nCTE for the Conditional Tail Expectation\nVaR for the percentile/Value at Risk\nWangTransform for the Wang Transformation\nProportionalHazard for proportional hazards\nDualPower for dual power measure","category":"section"},{"location":"#Insurance-mechanics","page":"Overview","title":"Insurance mechanics","text":"duration:\nCalculate the duration given an issue date and date (a.k.a. policy duration)","category":"section"},{"location":"#Typed-Rates","page":"Overview","title":"Typed Rates","text":"functions which return a rate/yield will return a FinanceCore.Rate object. E.g. irr(cashflows) will return a Rate(0.05,Periodic(1)) instead of just a 0.05 (float64) to convey the compounding frequency. This is compatible across the JuliaActuary ecosystem and can be used anywhere you would otherwise use a simple floating point rate.\n\nA couple of other notes:\n\nrate(...) will return the scalar rate value from a Rate struct:\n\njulia> r = Rate(0.05,Periodic(1));\n\njulia> rate(r) \n0.05\n\nYou can still pass a simple floating point rate to various methods. E.g. these two are the same (the default compounding convention is periodic once per period):\n\ndiscount(0.05,cashflows)\n\nr = Rate(0.05,Periodic(1));\ndiscount(r,cashflows)\n\nconvert between rates with:\n\nr = Rate(0.05,Periodic(1));\n\nconvert(Periodic(2),  r)   # convert to compounded twice per timestep\nconvert(Continuous(2),r)   # convert to compounded twice per timestep\n\nFor more on Rates, see FinanceCore.jl. FinanceModels.jl also provides a rich and flexible set of yield models to use.","category":"section"},{"location":"#Documentation","page":"Overview","title":"Documentation","text":"Full documentation is available here.","category":"section"},{"location":"#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"#Interactive,-basic-cashflow-analysis","page":"Overview","title":"Interactive, basic cashflow analysis","text":"See JuliaActuary.org for instructions on running this example.\n\n(Image: Simple cashflow analysis with ActuaryUtilities.jl)","category":"section"},{"location":"#Useful-tips","page":"Overview","title":"Useful tips","text":"Functions often use a mix of interest_rates, cashflows, and timepoints. When calling functions, the general order of the arguments is 1) interest rates, 2) cashflows, and 3) timepoints.","category":"section"}]
}
