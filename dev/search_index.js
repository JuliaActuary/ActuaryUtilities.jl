var documenterSearchIndex = {"docs":
[{"location":"risk_measures/#Risk-Measures","page":"Risk Measures","title":"Risk Measures","text":"","category":"section"},{"location":"risk_measures/#Quickstart","page":"Risk Measures","title":"Quickstart","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"outcomes = rand(100)\n\n# direct usage\nVaR(0.90)(outcomes) # ≈ 0.90  \nCTE(0.90)(outcomes) # ≈ 0.95  \nWangTransform(0.90)(outcomes) # ≈ 0.81\n\n# construct a reusable object (functor)\nrm = VaR(0.90)\n\nrm(outcomes) # ≈ 0.90","category":"page"},{"location":"risk_measures/#Introduction","page":"Risk Measures","title":"Introduction","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Risk measures encompass the set of functions that map a set of outcomes to an output value characterizing the associated riskiness of those outcomes. As is usual when attempting to compress information (e.g. condensing information into a single value), there are multiple ways we can characterize this riskiness.","category":"page"},{"location":"risk_measures/#Coherence-and-Other-Desirable-Properties","page":"Risk Measures","title":"Coherence & Other Desirable Properties","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Further, it is desirable that a risk measure has certain properties, and risk measures that meet the first four criteria are called \"Coherent\" in the literature.  From \"An Introduction to Risk Measures for Actuarial Applications\" (Hardy), she describes as follows:","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Using H as a risk measure and X as the associated risk distribution:","category":"page"},{"location":"risk_measures/#1.-Translation-Invariance","page":"Risk Measures","title":"1. Translation Invariance","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"For any non-random c","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"%H(X + c) = H(X) + c% This means that adding a constant amount (positive or negative) to a risk adds the same amount to the risk measure. It also implies that the risk measure for a non-random loss, with known value c, say, is just the amount of the loss c.","category":"page"},{"location":"risk_measures/#2.-Positive-Homogeneity","page":"Risk Measures","title":"2. Positive Homogeneity","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"For any non-random λ  0:","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"H(λX) = λH(X)","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"This axiom implies that changing the units of loss does not change the risk measure.","category":"page"},{"location":"risk_measures/#3.-Subadditivity","page":"Risk Measures","title":"3. Subadditivity","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"For any two random losses X and Y,","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"H(X + Y)  H(X) + H(Y)","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"It should not be possible to reduce the economic capital required (or the appropriate premium) for a risk by splitting it into constituent parts. Or, in other words, diversification (ie consolidating risks) cannot make the risk greater, but it might make the risk smaller if the risks are less than perfectly correlated.","category":"page"},{"location":"risk_measures/#4.-Monotonicity","page":"Risk Measures","title":"4. Monotonicity","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"If Pr(X  Y) = 1 then H(X)  H(Y).","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"If one risk is always bigger then another, the risk measures should be similarly ordered.","category":"page"},{"location":"risk_measures/#Other-Properties","page":"Risk Measures","title":"Other Properties","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"In \"Properties of Distortion Risk Measures\" (Balbás, Garrido, Mayoral) also note other properties of interest:","category":"page"},{"location":"risk_measures/#Complete","page":"Risk Measures","title":"Complete","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Completeness is the property that the distortion function associated with the risk measure produces a unique mapping between the original risk's survival function S(x) and the distorted  S*(x) for each x. See Distortion Risk Measures for more detail on this.","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"In practice, this means that a non-complete risk measure ignores some part of the risk distribution (e.g. CTE and VaR don't use the full distribution and have the same)","category":"page"},{"location":"risk_measures/#Exhaustive","page":"Risk Measures","title":"Exhaustive","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"A risk measure is \"exhaustive\" if it is coherent and complete.","category":"page"},{"location":"risk_measures/#Adaptable","page":"Risk Measures","title":"Adaptable","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"A risk measure is \"adapted\" or \"adaptable\" if its distortion function (ee Distortion Risk Measures). g:","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"1. $g$ is strictly concave, that is $g$ is strictly decreasing. \n2. $lim_{u\\to0+} g\\prime(u) = \\inf and lim_{u\\to1-} g\\prime(u) = 0.","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Adaptive risk measures are exhaustive but the converse is not true.","category":"page"},{"location":"risk_measures/#Summary-of-Risk-Measure-Properties","page":"Risk Measures","title":"Summary of Risk Measure Properties","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Measure Coherent Complete Exhaustive Adaptable Condition 2\nVaR No No No No No\nCTE Yes No No No No\nDualPower (y  1) Yes Yes Yes No Yes\nProportionalHazard (γ  1) Yes Yes Yes No Yes\nWangTransform Yes Yes Yes Yes Yes","category":"page"},{"location":"risk_measures/#Distortion-Risk-Measures","page":"Risk Measures","title":"Distortion Risk Measures","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Distortion Risk Measures (Wikipedia Link) are a way of remapping the probabilities of a risk distribution in order to compute a risk measure H on the risk distribution X.","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Adapting Wang (2002), there are two key components:","category":"page"},{"location":"risk_measures/#Distortion-Function-g(u)","page":"Risk Measures","title":"Distortion Function g(u)","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"This remaps values in the [0,1] range to another value in the [0,1] range, and in H below, operates on the survival function S and F=1-S.","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Let g01to01 be an increasing function with g(0)=0 and g(1)=1. The transform F^*(x)=g(F(x)) defines a distorted probability distribution, where \"g\" is called a distortion function.","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Note that F^* and F are equivalent probability measures if and only if g01to01 is continuous and one-to-one. Definition 4.2. We define a family of distortion risk-measures using the mean-value under the distorted probability F^*(x)=g(F(x)):","category":"page"},{"location":"risk_measures/#Risk-Measure-Integration","page":"Risk Measures","title":"Risk Measure Integration","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"To calculate a risk measure H, we integrate the distorted F across all possible values in the risk distribution (i.e. x in X):","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"H(X) = E^*(X) = - int_-infty^0 g(F(x))dx + int_0^+infty1-g(F(x))dx","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"That is, the risk measure (H) is equal to the expected value of the distortion of the risk distribution (E^*(X)).","category":"page"},{"location":"risk_measures/#Examples","page":"Risk Measures","title":"Examples","text":"","category":"section"},{"location":"risk_measures/#Basic-Usage","page":"Risk Measures","title":"Basic Usage","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"outcomes = rand(100)\n\n# direct usage\nVaR(0.90)(outcomes) # ≈ 0.90  \nCTE(0.90)(outcomes) # ≈ 0.95  \nWangTransform(0.90)(outcomes) # ≈ 0.81\n\n# construct a reusable object (functor)\nrm = VaR(0.90)\n\nrm(outcomes) # ≈ 0.90","category":"page"},{"location":"risk_measures/#Comparison","page":"Risk Measures","title":"Comparison","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"We will generate a random outcome and show how the risk measures behave:","category":"page"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"using Distributions\nusing ActuaryUtilities\nusing CairoMakie\n\noutcomes = Weibull(1,5)\n# or this could be discrete outcomes as in the next line\n#outcomes = rand(LogNormal(2,10)*100,2000) \n\nαs= range(0.00,0.99;length=100)\n\nlet \n    f = Figure()\n    ax = Axis(f[1,1],\n        xlabel=\"α\",\n        ylabel=\"Loss\",\n        title = \"Comparison of Risk Measures\",\n        xgridvisible=false,\n        ygridvisible=false,\n    )\n\n    lines!(ax,\n        αs,\n        [quantile(outcomes, α) for α in αs],\n        label = \"Quantile α of Outcome\",\n        color = :grey10,\n        linewidth = 3,\n        )\n    \n    lines!(ax,\n        αs,\n        [VaR(α)(outcomes) for α in αs],\n        label = \"VaR(α)\",\n        linestyle=:dash\n        )\n    lines!(ax,\n        αs,\n        [CTE(α)(outcomes) for α in αs],\n        label = \"CTE(α)\",\n        )\n    lines!(ax,\n        αs[2:end],\n        [WangTransform(α)(outcomes) for α in αs[2:end]],\n        label = \"WangTransform(α)\",\n        )\n    lines!(ax,\n        αs,\n        [ProportionalHazard(2)(outcomes) for α in αs],\n        label = \"ProportionalHazard(2)\",\n        )\n    \n    lines!(ax,\n        αs,\n        [DualPower(2)(outcomes) for α in αs],\n        label = \"DualPower(2)\",\n        )\n    lines!(ax,\n        αs,\n        [RiskMeasures.Expectation()(outcomes) for α in αs],\n        label = \"Expectation\",\n        )\n    axislegend(ax,position=:lt)\n\n        f\nend","category":"page"},{"location":"risk_measures/#API","page":"Risk Measures","title":"API","text":"","category":"section"},{"location":"risk_measures/#Exported-API","page":"Risk Measures","title":"Exported API","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Modules = [ActuaryUtilities.RiskMeasures]\nPrivate = false","category":"page"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.CTE","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.CTE","text":"CTE(α)::RiskMeasure\nCTE(α)(risk)::T (where T is the type of values sampled in risk)\n\nThe Conditional Tail Expectation (CTE) at level α is the expected value of the risk distribution above the αth quantile. risk can be a univariate distribution or an array of outcomes. Assumes more positive values are higher risk measures, so a higher p will return a more positive number.\n\nCTE(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0) \n\nExamples\n\njulia> CTE(0.95)(rand(1000))\n0.9766218612020593\n\njulia> rm = CTE(0.95)\nCTE{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.9739835010268733\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ConditionalTailExpectation","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ConditionalTailExpectation","text":"CTE\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.DualPower","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.DualPower","text":"DualPower(v)::RiskMeasure\nDualPower(v)(risk)::T (where T is the type of values sampled in risk)\n\nThe Dual Power distortion risk measure is defined as 1 - (1 - x)^v, where x is the cumulative distribution function (CDF) of the risk distribution and v is a positive parameter. risk can be a univariate distribution or an array of outcomes.\n\nDualPower(v) returns a functor which can then be called on a risk distribution.\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ProportionalHazard","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ProportionalHazard","text":"ProportionalHazard(y)::RiskMeasure\nProportionalHazard(y)(risk)::T (where T is the type of values sampled in risk)\n\nThe Proportional Hazard distortion risk measure is defined as x^(1y), where x is the cumulative distribution function (CDF) of the risk distribution and y is a positive parameter. risk can be a univariate distribution or an array of outcomes. ProportionalHazard(y) returns a functor which can then be called on a risk distribution.\n\nExamples\n\njulia> ProportionalHazard(2)(rand(1000))\n0.6659603556774121\n\njulia> rm = ProportionalHazard(2)\nProportionalHazard{Int64}(2)\n\njulia> rm(rand(1000))\n0.6710587338367799\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.VaR","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.VaR","text":" VaR(α)::RiskMeasure\n VaR(α)(risk)::T (where T is the type of values sampled in `risk`)\n\nThe αth quantile of the risk distribution is the Value at Risk, or αth quantile. risk can be a univariate distribution or an array of outcomes. Assumes more positive values are higher risk measures, so a higher p will return a more positive number. For a discrete risk, the VaR returned is the first value above the αth percentile.\n\nVaR(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0) \n\nExamples\n\njulia> VaR(0.95)(rand(1000))\n0.9561843082268024\n\njulia> rm = VaR(0.95)\nVaR{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.9597070153670079\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.ValueAtRisk","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.ValueAtRisk","text":"VaR\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.WangTransform","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.WangTransform","text":"WangTransform(α)::RiskMeasure\nWangTransform(α)(risk)::T (where T is the type of values sampled in risk)\n\nThe Wang Transform is a distortion risk measure that transforms the cumulative distribution function (CDF) of the risk distribution using a normal distribution with mean Φ⁻¹(α) and standard deviation 1. risk can be a univariate distribution or an array of outcomes.\n\nWangTransform(α) returns a functor which can then be called on a risk distribution.\n\nParameters\n\nα: [0,1.0]\n\nIn the literature, sometimes λ is used where lambda = Phi^-1(alpha).\n\nExamples\n\njulia> WangTransform(0.95)(rand(1000))\n0.8799465543360105\n\njulia> rm = WangTransform(0.95)\nWangTransform{Float64}(0.95)\n\njulia> rm(rand(1000))\n0.8892245759705852\n\nReferences\n\n\"A Risk Measure That Goes Beyond Coherence\", Shaun S. Wang, 2002\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#Unexported-API","page":"Risk Measures","title":"Unexported API","text":"","category":"section"},{"location":"risk_measures/","page":"Risk Measures","title":"Risk Measures","text":"Modules = [ActuaryUtilities.RiskMeasures]\nPublic = false","category":"page"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.Expectation","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.Expectation","text":"Expectation()::RiskMeasure\nExpectation()(risk)::T (where T is the type of values sampled in `risk`)\n\nThe expected value of the risk.\n\nExpectation() returns a functor which can then be called on a risk distribution.\n\nExamples\n\njulia> RiskMeasures.Expectation(rand(1000))\n0.4793223308812537\n\njulia> rm = RiskMeasures.Expectation()\nActuaryUtilities.RiskMeasures.Expectation()\n\njulia> rm(rand(1000))\n0.4941708036889741\n\n\n\n\n\n","category":"type"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.cdf_func-Tuple{AbstractArray{<:Real}}","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.cdf_func","text":"cdf_function(risk)\n\nReturns the appropriate cumulative distribution function depending on the type, specifically:\n\ncdf_func(S::AbstractArray{<:Real}) = StatsBase.ecdf(S)\ncdf_func(S::Distributions.UnivariateDistribution) = x -> Distributions.cdf(S, x)\n\n\n\n\n\n","category":"method"},{"location":"risk_measures/#ActuaryUtilities.RiskMeasures.g-Tuple{ActuaryUtilities.RiskMeasures.RiskMeasure, Any}","page":"Risk Measures","title":"ActuaryUtilities.RiskMeasures.g","text":"g(rm::RiskMeasure,x)\n\nThe probability distortion function associated with the given risk measure.\n\nSee Distortion Function g(u)\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities-API-Reference","page":"ActuaryUtilities","title":"ActuaryUtilities API Reference","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]","category":"page"},{"location":"API/ActuaryUtilities/#Exported-API","page":"ActuaryUtilities","title":"Exported API","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]\nPrivate = false","category":"page"},{"location":"API/ActuaryUtilities/#Unexported-API","page":"ActuaryUtilities","title":"Unexported API","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]\nPublic = false","category":"page"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"financial_math/#Financial-Math-Submodule","page":"Financial Math","title":"Financial Math Submodule","text":"","category":"section"},{"location":"financial_math/","page":"Financial Math","title":"Financial Math","text":"Provides a set of common routines in financial maths.","category":"page"},{"location":"financial_math/#Quickstart","page":"Financial Math","title":"Quickstart","text":"","category":"section"},{"location":"financial_math/","page":"Financial Math","title":"Financial Math","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"page"},{"location":"financial_math/#API","page":"Financial Math","title":"API","text":"","category":"section"},{"location":"financial_math/#Exported-API","page":"Financial Math","title":"Exported API","text":"","category":"section"},{"location":"financial_math/","page":"Financial Math","title":"Financial Math","text":"Modules = [ActuaryUtilities.FinancialMath]\nPrivate = false","category":"page"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRate","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRate","text":"KeyRate(timepoints,shift=0.001)\n\nA convenience constructor for KeyRateZero. \n\nExtended Help\n\nKeyRateZero is chosen as the default constructor because it has more attractive properties than KeyRatePar:\n\nrates after the key timepoint remain unaffected by the shift\ne.g. this causes a 6-year zero coupon bond would have a negative duration if the 5-year par rate was used\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRatePar","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRatePar","text":"KeyRatePar(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration. \n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDurations are computed via a shift-and-compute the yield curve approach.\n\nKeyRatePar is more commonly reported (than KeyRateZero) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.KeyRateZero","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.KeyRateZero","text":"KeyRateZero(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration.\n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDuration is computed via a shift-and-compute the yield curve approach.\n\nKeyRateZero is less commonly reported (than KeyRatePar) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.breakeven","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.breakeven","text":"breakeven(yield, cashflows::Vector)\nbreakeven(yield, cashflows::Vector,times::Vector)\n\nCalculate the time when the accumulated cashflows breakeven given the yield.\n\nAssumptions:\n\ncashflows occur at the end of the period\ncashflows evenly spaced with the first one occuring at time zero if times not given\n\nReturns nothing if cashflow stream never breaks even.\n\njulia> breakeven(0.10, [-10,1,2,3,4,8])\n5\n\njulia> breakeven(0.10, [-10,15,2,3,4,8])\n1\n\njulia> breakeven(0.10, [-10,-15,2,3,4,8]) # returns the `nothing` value\n\n\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.convexity-Tuple{Any, Any, Any}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.convexity","text":"convexity(yield,cfs,times)\nconvexity(yield,valuation_function)\n\nCalculates the convexity.     - yield should be a fixed effective yield (e.g. 0.05).     - times may be omitted and it will assume cfs are evenly spaced beginning at the end of the first period.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5\njulia> cfs = [0,0,0,0,100]\njulia> duration(0.03,cfs,times)\n4.854368932038834\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.moic-Tuple{T} where T<:AbstractArray","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.moic","text":"moic(cashflows<:AbstractArray)\n\nThe multiple on invested capital (\"moic\") is the un-discounted sum of distributions divided by the sum of the contributions. The function assumes that negative numbers in the array represent contributions and positive numbers represent distributions.\n\nExamples\n\njulia> moic([-10,20,30])\n5.0\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.present_values","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.present_values","text":"present_values(interest, cashflows, timepoints)\n\nEfficiently calculate a vector representing the present value of the given cashflows at each period prior to the given timepoint.\n\nExamples\n\njulia> present_values(0.00, [1,1,1])\n[3,2,1]\n\njulia> present_values(ForwardYield([0.1,0.2]), [10,20],[0,1]) # after `using FinanceModels`\n2-element Vector{Float64}:\n 28.18181818181818\n 18.18181818181818\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.price-Tuple{Any, Any}","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.price","text":"price(...)\n\nThe absolute value of the present_value(...). \n\nExtended help\n\nUsing price can be helpful if the directionality of the value doesn't matter. For example, in the common usage, duration is more interested in the change in price than present value, so price is used there.\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.FinancialMath.spread","page":"Financial Math","title":"ActuaryUtilities.FinancialMath.spread","text":"spread(curve1,curve2,cashflows)\n\nReturn the solved-for constant spread to add to curve1 in order to equate the discounted cashflows with curve2\n\nExamples\n\nspread(0.04, 0.05, cfs)\nRate{Float64, Periodic}(0.010000000000000009, Periodic(1))\n\n\n\n\n\n","category":"function"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{ActuaryUtilities.FinancialMath.KeyRateDuration, Vararg{Any, 4}}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any FinanceModels.jl curve (e.g. does not have to be a curve constructed via FinanceModels.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = FinanceModels.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#ActuaryUtilities.duration-Tuple{Macaulay, Any, Any, Any}","page":"Financial Math","title":"ActuaryUtilities.duration","text":"duration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, or DV01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\nNote that the calculated duration will depend on the periodicity convention of the interest_rate: a Periodic yield (or yield model with that convention) will be a slightly different computed duration than a Continous which follows from the present value differing according to the periodicity.\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nModified duration: the relative change per point of yield change.\nMacaulay: the cashflow-weighted average time.\nDV01: the absolute change per basis point (hundredth of a percentage point).\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5;\n\njulia> cfs = [0,0,0,0,100];\n\njulia> duration(0.03,cfs,times)\n4.854368932038835\n\njulia> duration(Periodic(0.03,1),cfs,times)\n4.854368932038835\n\njulia> duration(Continuous(0.03),cfs,times)\n5.0\n\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\n\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\n\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"financial_math/#Unexported-API","page":"Financial Math","title":"Unexported API","text":"","category":"section"},{"location":"financial_math/","page":"Financial Math","title":"Financial Math","text":"Modules = [ActuaryUtilities.FinancialMath]\nPublic = false","category":"page"},{"location":"upgrade/#Version-Upgrade-Guide","page":"Upgrade from Prior Versions","title":"Version Upgrade Guide","text":"","category":"section"},{"location":"upgrade/#v3-to-v4","page":"Upgrade from Prior Versions","title":"v3 to v4","text":"","category":"section"},{"location":"upgrade/#Overview","page":"Upgrade from Prior Versions","title":"Overview","text":"","category":"section"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"The shape and API of the package is mostly unchanged. The changes that have made fall into a few categores:","category":"page"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"Accommodating FinanceModels.jl, the next-generation version of Yields.jl.\nSimplifying the API, generally making function calls require more specific arguments to avoid ambiguity\nAccommodating the new Cashflow type which makes modeling heterogeneous assets and liabilities simpler.","category":"page"},{"location":"upgrade/#API-Changes","page":"Upgrade from Prior Versions","title":"API Changes","text":"","category":"section"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"Breaking: The functions europut and eurocall have been moved to FinanceModels\nBreaking: Previously, the first argument to present_value or present_values would be interpreted as a set of Periodic(1) one-period forward rates if a vector of real values was passed. Users should explicitly create the yield model first, instead of relying on the implicit conversion:","category":"page"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"# old \npv([0.05,0.1], cfs)  \n\n# new\nusing FinanceModels\ny = fit(Spline.Linear(),ForwardYields([0.05,0.1]),Bootstrap())\npv(y,cfs)\n","category":"page"},{"location":"utilities/#Utilities-submodule","page":"Other Utilities","title":"Utilities submodule","text":"","category":"section"},{"location":"utilities/","page":"Other Utilities","title":"Other Utilities","text":"Provides miscellaneous routines common in actuarial and financial work.","category":"page"},{"location":"utilities/#API","page":"Other Utilities","title":"API","text":"","category":"section"},{"location":"utilities/#Exported-API","page":"Other Utilities","title":"Exported API","text":"","category":"section"},{"location":"utilities/","page":"Other Utilities","title":"Other Utilities","text":"Utilities.duration\nUtilities.years_between\nUtilities.accum_offset","category":"page"},{"location":"utilities/#ActuaryUtilities.duration","page":"Other Utilities","title":"ActuaryUtilities.duration","text":"duration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, or DV01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\nNote that the calculated duration will depend on the periodicity convention of the interest_rate: a Periodic yield (or yield model with that convention) will be a slightly different computed duration than a Continous which follows from the present value differing according to the periodicity.\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nModified duration: the relative change per point of yield change.\nMacaulay: the cashflow-weighted average time.\nDV01: the absolute change per basis point (hundredth of a percentage point).\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5;\n\njulia> cfs = [0,0,0,0,100];\n\njulia> duration(0.03,cfs,times)\n4.854368932038835\n\njulia> duration(Periodic(0.03,1),cfs,times)\n4.854368932038835\n\njulia> duration(Continuous(0.03),cfs,times)\n5.0\n\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\n\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\n\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\nduration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any FinanceModels.jl curve (e.g. does not have to be a curve constructed via FinanceModels.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = FinanceModels.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\nduration(d1::Date, d2::Date)\n\nCompute the duration given two dates, which is the number of years since the first date. The interval [0,1) is defined as having  duration 1. Can return negative durations if second argument is before the first.\n\njulia> issue_date  = Date(2018,9,30);\n\njulia> duration(issue_date , Date(2019,9,30) ) \n2\njulia> duration(issue_date , issue_date) \n1\njulia> duration(issue_date , Date(2018,10,1) ) \n1\njulia> duration(issue_date , Date(2019,10,1) ) \n2\njulia> duration(issue_date , Date(2018,6,30) ) \n0\njulia> duration(Date(2018,9,30),Date(2017,6,30)) \n-1\n\n\n\n\n\n","category":"function"},{"location":"utilities/#ActuaryUtilities.Utilities.years_between","page":"Other Utilities","title":"ActuaryUtilities.Utilities.years_between","text":"Years_Between(d1::Date, d2::Date)\n\nCompute the number of integer years between two dates, with the  first date typically before the second. Will return negative number if first date is after the second. Use third argument to indicate if calendar  anniversary should count as a full year.\n\nExamples\n\njulia> d1 = Date(2018,09,30);\n\njulia> d2 = Date(2019,09,30);\n\njulia> d3 = Date(2019,10,01);\n\njulia> years_between(d1,d3) \n1\njulia> years_between(d1,d2,false) # same month/day but `false` overlap\n0 \njulia> years_between(d1,d2) # same month/day but `true` overlap\n1 \njulia> years_between(d1,d2) # using default `true` overlap\n1 \n\n\n\n\n\n","category":"function"},{"location":"utilities/#ActuaryUtilities.Utilities.accum_offset","page":"Other Utilities","title":"ActuaryUtilities.Utilities.accum_offset","text":"accum_offset(x; op=*, init=1.0)\n\nA shortcut for the common operation wherein a vector is scanned with an operation, but has an initial value and the resulting array is offset from the traditional accumulate. \n\nThis is a common pattern when calculating things like survivorship given a mortality vector and you want the first value of the resulting vector to be 1.0, and the second value to be 1.0 * x[1], etc.\n\nTwo keyword arguments:\n\nop is the binary (two argument) operator you want to use, such as * or +\ninit is the initial value in the returned array\n\nExamples\n\njulia> accum_offset([0.9, 0.8, 0.7])\n3-element Array{Float64,1}:\n 1.0\n 0.9\n 0.7200000000000001\n\njulia> accum_offset(1:5) # the product of elements 1:n, with the default `1` as the first value\n5-element Array{Int64,1}:\n  1\n  1\n  2\n  6\n 24\n\njulia> accum_offset(1:5,op=+)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  7\n 11\n\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore (re-exported)","title":"FinanceCore API Reference","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore (re-exported)","title":"FinanceCore (re-exported)","text":"Modules = [FinanceCore]","category":"page"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore (re-exported)","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore (re-exported)","title":"FinanceCore (re-exported)","text":"Modules = [FinanceCore]\nPrivate = false","category":"page"},{"location":"API/FinanceCore/#FinanceCore.Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.Cashflow","text":"Cashflow(amount,time)\n\nA Cahflow{A,B} is a contract that pays an amount at time. \n\nCashflows can be:\n\nnegated with the unary - operator. \nadded/subtracted together but note that the time must be isapprox equal.\nmultiplied/divided by a scalar.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nCashflow{A<:Real, B<:Timepoint} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore (re-exported)","title":"FinanceCore.Composite","text":"Composite(A,B)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore (re-exported)","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Continuous","text":"julia> Continuous(0.01)\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore (re-exported)","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency. \n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError). \n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Periodic","text":"Periodic(rate,frequency)\n\nA convenience constructor for Rate(rate,Periodic(frequency)).\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore (re-exported)","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\njulia> Continuous(0.01)\nRate(0.01, Continuous())\n\njulia> Continuous()(0.01)\nRate(0.01, Continuous())\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Periodic(2)(0.01)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01)\nRate(0.01, Periodic(1))\n\njulia> Rate(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01,Periodic(4))\nRate(0.01, Periodic(4))\n\njulia> Rate(0.01,Inf)\nRate(0.01, Continuous())\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore (re-exported)","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore (re-exported)","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate}","page":"FinanceCore (re-exported)","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the untyped scalar interest rate represented by the Rate.\n\nExamples\n\njulia> r =Continuous(0.03)\nYields.Rate{Float64, Continuous}(0.03, Continuous())\n\njulia> rate(r)\n0.03\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore (re-exported)","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore (re-exported)","title":"Unexported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore (re-exported)","title":"FinanceCore (re-exported)","text":"Modules = [FinanceCore]\nPublic = false","category":"page"},{"location":"API/FinanceCore/#FinanceCore.Timepoint","page":"FinanceCore (re-exported)","title":"FinanceCore.Timepoint","text":"Timepoint(a)\n\nSummary ≡≡≡≡≡≡≡≡≡\n\nTimepoint is a type alias for Union{T,Dates.Date} that can be used to represent a point in time. It can be either a Dates.Date or a Real number. If defined as a real number, the interpretation is the number of (fractional) periods since time zero.\n\nCurrently, the usage of Dates.Date is not well supported across the JuliaActuary ecosystem but this type is in place such that it can be built upon further.\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nTimepoint{T} = Union{T,Dates.Date} <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore (re-exported)","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:<-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore (re-exported)","title":"Base.:<","text":"<(x::Rate,y::Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a lower force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) < Yields.Continuous(0.03)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:>-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore (re-exported)","title":"Base.:>","text":">(Rate,Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a greater force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) > Yields.Continuous(0.03)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore (re-exported)","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/","page":"FinanceCore (re-exported)","title":"FinanceCore (re-exported)","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"#Quickstart","page":"Overview","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"page"},{"location":"#Features","page":"Overview","title":"Features","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"A collection of common functions/manipulations used in Actuarial Calculations.","category":"page"},{"location":"#Financial-Maths","page":"Overview","title":"Financial Maths","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"duration:\nCalculate the Macaulay, Modified, or DV01 durations for a set of cashflows\nCalculate the KeyRate(time) (a.k.a. KeyRateZero)duration or KeyRatePar(time) duration\nconvexity for price sensitivity\nFlexible interest rate models via the FinanceModels.jl package.\ninternal_rate_of_return or irr to calculate the IRR given cashflows (including at timepoints like Excel's XIRR)\nbreakeven to calculate the breakeven time for a set of cashflows\naccum_offset to calculate accumulations like survivorship from a mortality vector\nspread will calculate the spread needed between two yield curves to equate a set of cashflows","category":"page"},{"location":"#Risk-Measures","page":"Overview","title":"Risk Measures","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Calculate risk measures for a given vector of risks:\nCTE for the Conditional Tail Expectation\nVaR for the percentile/Value at Risk\nWangTransform for the Wang Transformation\nProportionalHazard for proportional hazards\nDualPower for dual power measure","category":"page"},{"location":"#Insurance-mechanics","page":"Overview","title":"Insurance mechanics","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"duration:\nCalculate the duration given an issue date and date (a.k.a. policy duration)","category":"page"},{"location":"#Typed-Rates","page":"Overview","title":"Typed Rates","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"functions which return a rate/yield will return a FinanceCore.Rate object. E.g. irr(cashflows) will return a Rate(0.05,Periodic(1)) instead of just a 0.05 (float64) to convey the compounding frequency. This is compatible across the JuliaActuary ecosystem and can be used anywhere you would otherwise use a simple floating point rate.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"A couple of other notes:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"rate(...) will return the scalar rate value from a Rate struct:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"julia> r = Rate(0.05,Periodic(1));\n\njulia> rate(r) \n0.05","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"You can still pass a simple floating point rate to various methods. E.g. these two are the same (the default compounding convention is periodic once per period):","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"discount(0.05,cashflows)\n\nr = Rate(0.05,Periodic(1));\ndiscount(r,cashflows)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"convert between rates with:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"r = Rate(0.05,Periodic(1));\n\nconvert(Periodic(2),  r)   # convert to compounded twice per timestep\nconvert(Continuous(2),r)   # convert to compounded twice per timestep","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For more on Rates, see FinanceCore.jl. FinanceModels.jl also provides a rich and flexible set of yield models to use.","category":"page"},{"location":"#Documentation","page":"Overview","title":"Documentation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Full documentation is available here.","category":"page"},{"location":"#Examples","page":"Overview","title":"Examples","text":"","category":"section"},{"location":"#Interactive,-basic-cashflow-analysis","page":"Overview","title":"Interactive, basic cashflow analysis","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"See JuliaActuary.org for instructions on running this example.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Simple cashflow analysis with ActuaryUtilities.jl)","category":"page"},{"location":"#Useful-tips","page":"Overview","title":"Useful tips","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Functions often use a mix of interest_rates, cashflows, and timepoints. When calling functions, the general order of the arguments is 1) interest rates, 2) cashflows, and 3) timepoints.","category":"page"}]
}
