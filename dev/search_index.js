var documenterSearchIndex = {"docs":
[{"location":"API/ActuaryUtilities/#ActuaryUtilities-API-Reference","page":"ActuaryUtilities","title":"ActuaryUtilities API Reference","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]","category":"page"},{"location":"API/ActuaryUtilities/#Exported-API","page":"ActuaryUtilities","title":"Exported API","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]\nPrivate = false","category":"page"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.KeyRate","page":"ActuaryUtilities","title":"ActuaryUtilities.KeyRate","text":"KeyRate(timepoints,shift=0.001)\n\nA convenience constructor for KeyRateZero. \n\nExtended Help\n\nKeyRateZero is chosen as the default constructor because it has more attractive properties than KeyRatePar:\n\nrates after the key timepoint remain unaffected by the shift\ne.g. this causes a 6-year zero coupon bond would have a negative duration if the 5-year par rate was used\n\n\n\n\n\n","category":"type"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.KeyRatePar","page":"ActuaryUtilities","title":"ActuaryUtilities.KeyRatePar","text":"KeyRatePar(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration. \n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDurations are computed via a shift-and-compute the yield curve approach.\n\nKeyRatePar is more commonly reported (than KeyRateZero) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.KeyRateZero","page":"ActuaryUtilities","title":"ActuaryUtilities.KeyRateZero","text":"KeyRateZero(timepoint,shift=0.001) <: KeyRateDuration\n\nShift the par curve by the given amount at the given timepoint. Use in conjunction with duration to calculate the key rate duration.\n\nUnlike other duration statistics which are computed using analytic derivatives, KeyRateDuration is computed via a shift-and-compute the yield curve approach.\n\nKeyRateZero is less commonly reported (than KeyRatePar) in the fixed income markets, even though the latter has more analytically attractive properties. See the discussion of KeyRateDuration in the FinanceModels.jl docs.\n\n\n\n\n\n","category":"type"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.CTE-Tuple{Any, Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.CTE","text":"CTE(v::AbstractArray,p::Real;rev::Bool=false)\n\nThe average of the values ≥ the pth percentile of the vector v is the Conditiona Tail Expectation. Assumes more positive values are higher risk measures, so a higher p will return a more positive number, but this can be reversed if rev is true.\n\nMay also be called with ConditionalTailExpectation(...).\n\nAlso known as Tail Value at Risk (TVaR), or Tail Conditional Expectation (TCE)\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.ConditionalTailExpectation","page":"ActuaryUtilities","title":"ActuaryUtilities.ConditionalTailExpectation","text":"CTE\n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.VaR-Tuple{Any, Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.VaR","text":"VaR(v::AbstractArray,p::Real;rev::Bool=false)\n\nThe pth quantile of the vector v is the Value at Risk. Assumes more positive values are higher risk measures, so a higher p will return a more positive number, but this can be reversed if rev is true.\n\nAlso can be called with ValueAtRisk(...).\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.ValueAtRisk","page":"ActuaryUtilities","title":"ActuaryUtilities.ValueAtRisk","text":"VaR\n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.accum_offset-Tuple{Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.accum_offset","text":"accum_offset(x; op=*, init=1.0)\n\nA shortcut for the common operation wherein a vector is scanned with an operation, but has an initial value and the resulting array is offset from the traditional accumulate. \n\nThis is a common pattern when calculating things like survivorship given a mortality vector and you want the first value of the resulting vector to be 1.0, and the second value to be 1.0 * x[1], etc.\n\nTwo keyword arguments:\n\nop is the binary (two argument) operator you want to use, such as * or +\ninit is the initial value in the returned array\n\nExamples\n\njulia> accum_offset([0.9, 0.8, 0.7])\n3-element Array{Float64,1}:\n 1.0\n 0.9\n 0.7200000000000001\n\njulia> accum_offset(1:5) # the product of elements 1:n, with the default `1` as the first value\n5-element Array{Int64,1}:\n  1\n  1\n  2\n  6\n 24\n\njulia> accum_offset(1:5,op=+)\n5-element Array{Int64,1}:\n  1\n  2\n  4\n  7\n 11\n\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.breakeven","page":"ActuaryUtilities","title":"ActuaryUtilities.breakeven","text":"breakeven(yield, cashflows::Vector)\nbreakeven(yield, cashflows::Vector,times::Vector)\n\nCalculate the time when the accumulated cashflows breakeven given the yield.\n\nAssumptions:\n\ncashflows occur at the end of the period\ncashflows evenly spaced with the first one occuring at time zero if times not given\n\nReturns nothing if cashflow stream never breaks even.\n\njulia> breakeven(0.10, [-10,1,2,3,4,8])\n5\n\njulia> breakeven(0.10, [-10,15,2,3,4,8])\n1\n\njulia> breakeven(0.10, [-10,-15,2,3,4,8]) # returns the `nothing` value\n\n\n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.convexity-Tuple{Any, Any, Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.convexity","text":"convexity(yield,cfs,times)\nconvexity(yield,valuation_function)\n\nCalculates the convexity.     - yield should be a fixed effective yield (e.g. 0.05).     - times may be omitted and it will assume cfs are evenly spaced beginning at the end of the first period.\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5\njulia> cfs = [0,0,0,0,100]\njulia> duration(0.03,cfs,times)\n4.854368932038834\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.duration-Tuple{ActuaryUtilities.KeyRateDuration, Vararg{Any, 4}}","page":"ActuaryUtilities","title":"ActuaryUtilities.duration","text":"duration(keyrate::KeyRateDuration,curve,cashflows)    \nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints)\nduration(keyrate::KeyRateDuration,curve,cashflows,timepoints,krd_points)\n\nCalculate the key rate duration by shifting the zero (not par) curve by the kwarg shift at the timepoint specified by a KeyRateDuration(time).\n\nThe approach is to carve up the curve into krd_points (default is the unit steps between 1 and  the last timepoint of the casfhlows). The  zero rate corresponding to the timepoint within the KeyRateDuration is shifted by shift (specified by the KeyRateZero or KeyRatePar constructors. A new curve is created from the shifted rates. This means that the  \"width\" of the shifted section is ± 1 time period, unless specific points are specified via krd_points.\n\nThe curve may be any FinanceModels.jl curve (e.g. does not have to be a curve constructed via FinanceModels.Zero(...)).\n\n!!! Experimental: Due to the paucity of examples in the literature, this feature does not have unit tests like the rest of JuliaActuary functionality. Additionally, the API may change in a future major/minor version update.\n\nExamples\n\njulia> riskfree_maturities = [0.5, 1.0, 1.5, 2.0];\n\njulia> riskfree    = [0.05, 0.058, 0.064,0.068];\n\njulia> rf_curve = FinanceModels.Zero(riskfree,riskfree_maturities);\n\njulia> cfs = [10,10,10,10,10];\n\njulia> duration(KeyRate(1),rf_curve,cfs)\n8.932800152336995\n\n\nExtended Help\n\nKey Rate Duration is not a well specified topic in the literature and in practice. The reference below suggest that shocking the par curve is more common  in practice, but that the zero curve produces more consistent results. Future versions may support shifting the par curve.\n\nReferences: \n\nQuant Finance Stack Exchange: To compute key rate duration, shall I use par curve or zero curve?\n(Financial Exam Help 123](http://www.financialexamhelp123.com/key-rate-duration/)\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.duration-Tuple{Dates.Date, Dates.Date}","page":"ActuaryUtilities","title":"ActuaryUtilities.duration","text":"duration(d1::Date, d2::Date)\n\nCompute the duration given two dates, which is the number of years since the first date. The interval [0,1) is defined as having  duration 1. Can return negative durations if second argument is before the first.\n\njulia> issue_date  = Date(2018,9,30);\n\njulia> duration(issue_date , Date(2019,9,30) ) \n2\njulia> duration(issue_date , issue_date) \n1\njulia> duration(issue_date , Date(2018,10,1) ) \n1\njulia> duration(issue_date , Date(2019,10,1) ) \n2\njulia> duration(issue_date , Date(2018,6,30) ) \n0\njulia> duration(Date(2018,9,30),Date(2017,6,30)) \n-1\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.duration-Tuple{Macaulay, Any, Any, Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.duration","text":"duration(Macaulay(),interest_rate,cfs,times)\nduration(Modified(),interest_rate,cfs,times)\nduration(DV01(),interest_rate,cfs,times)\nduration(interest_rate,cfs,times)             # Modified Duration\nduration(interest_rate,valuation_function)    # Modified Duration\n\nCalculates the Macaulay, Modified, or DV01 duration. times may be ommitted and the valuation will assume evenly spaced cashflows starting at the end of the first period.\n\nNote that the calculated duration will depend on the periodicity convention of the interest_rate: a Periodic yield (or yield model with that convention) will be a slightly different computed duration than a Continous which follows from the present value differing according to the periodicity.\n\nWhen not given Modified() or Macaulay() as an argument, will default to Modified().\n\nModified duration: the relative change per point of yield change.\nMacaulay: the cashflow-weighted average time.\nDV01: the absolute change per basis point (hundredth of a percentage point).\n\nExamples\n\nUsing vectors of cashflows and times\n\njulia> times = 1:5;\n\njulia> cfs = [0,0,0,0,100];\n\njulia> duration(0.03,cfs,times)\n4.854368932038835\n\njulia> duration(Periodic(0.03,1),cfs,times)\n4.854368932038835\n\njulia> duration(Continuous(0.03),cfs,times)\n5.0\n\njulia> duration(Macaulay(),0.03,cfs,times)\n5.0\n\njulia> duration(Modified(),0.03,cfs,times)\n4.854368932038835\n\njulia> convexity(0.03,cfs,times)\n28.277877274012614\n\n\nUsing any given value function: \n\njulia> lump_sum_value(amount,years,i) = amount / (1 + i ) ^ years\njulia> my_lump_sum_value(i) = lump_sum_value(100,5,i)\njulia> duration(0.03,my_lump_sum_value)\n4.854368932038835\njulia> convexity(0.03,my_lump_sum_value)\n28.277877274012617\n\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.moic-Tuple{T} where T<:AbstractArray","page":"ActuaryUtilities","title":"ActuaryUtilities.moic","text":"moic(cashflows<:AbstractArray)\n\nThe multiple on invested capital (\"moic\") is the un-discounted sum of distributions divided by the sum of the contributions. The function assumes that negative numbers in the array represent contributions and positive numbers represent distributions.\n\nExamples\n\njulia> moic([-10,20,30])\n5.0\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.present_values","page":"ActuaryUtilities","title":"ActuaryUtilities.present_values","text":"present_values(interest, cashflows, timepoints)\n\nEfficiently calculate a vector representing the present value of the given cashflows at each period prior to the given timepoint.\n\nExamples\n\njulia> present_values(0.00, [1,1,1])\n[3,2,1]\n\njulia> present_values(ForwardYield([0.1,0.2]), [10,20],[0,1]) # after `using FinanceModels`\n2-element Vector{Float64}:\n 28.18181818181818\n 18.18181818181818\n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.price-Tuple{Any, Any}","page":"ActuaryUtilities","title":"ActuaryUtilities.price","text":"price(...)\n\nThe absolute value of the present_value(...). \n\nExtended help\n\nUsing price can be helpful if the directionality of the value doesn't matter. For example, in the common usage, duration is more interested in the change in price than present value, so price is used there.\n\n\n\n\n\n","category":"method"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.spread","page":"ActuaryUtilities","title":"ActuaryUtilities.spread","text":"spread(curve1,curve2,cashflows)\n\nReturn the solved-for constant spread to add to curve1 in order to equate the discounted cashflows with curve2\n\nExamples\n\nspread(0.04, 0.05, cfs)\nRate{Float64, Periodic}(0.010000000000000009, Periodic(1))\n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#ActuaryUtilities.years_between","page":"ActuaryUtilities","title":"ActuaryUtilities.years_between","text":"Years_Between(d1::Date, d2::Date)\n\nCompute the number of integer years between two dates, with the  first date typically before the second. Will return negative number if first date is after the second. Use third argument to indicate if calendar  anniversary should count as a full year.\n\nExamples\n\njulia> d1 = Date(2018,09,30);\n\njulia> d2 = Date(2019,09,30);\n\njulia> d3 = Date(2019,10,01);\n\njulia> years_between(d1,d3) \n1\njulia> years_between(d1,d2,false) # same month/day but `false` overlap\n0 \njulia> years_between(d1,d2) # same month/day but `true` overlap\n1 \njulia> years_between(d1,d2) # using default `true` overlap\n1 \n\n\n\n\n\n","category":"function"},{"location":"API/ActuaryUtilities/#Unexported-API","page":"ActuaryUtilities","title":"Unexported API","text":"","category":"section"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Modules = [ActuaryUtilities]\nPublic = false","category":"page"},{"location":"API/ActuaryUtilities/","page":"ActuaryUtilities","title":"ActuaryUtilities","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"upgrade/#Version-Upgrade-Guide","page":"Upgrade from Prior Versions","title":"Version Upgrade Guide","text":"","category":"section"},{"location":"upgrade/#v3-to-v4","page":"Upgrade from Prior Versions","title":"v3 to v4","text":"","category":"section"},{"location":"upgrade/#Overview","page":"Upgrade from Prior Versions","title":"Overview","text":"","category":"section"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"The shape and API of the package is mostly unchanged. The changes that have made fall into a few categores:","category":"page"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"Accommodating FinanceModels.jl, the next-generation version of Yields.jl.\nSimplifying the API, generally making function calls require more specific arguments to avoid ambiguity\nAccommodating the new Cashflow type which makes modeling heterogeneous assets and liabilities simpler.","category":"page"},{"location":"upgrade/#API-Changes","page":"Upgrade from Prior Versions","title":"API Changes","text":"","category":"section"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"Breaking: The functions europut and eurocall have been moved to FinanceModels\nBreaking: Previously, the first argument to present_value or present_values would be interpreted as a set of Periodic(1) one-period forward rates if a vector of real values was passed. Users should explicitly create the yield model first, instead of relying on the implicit conversion:","category":"page"},{"location":"upgrade/","page":"Upgrade from Prior Versions","title":"Upgrade from Prior Versions","text":"# old \npv([0.05,0.1], cfs)  \n\n# new\nusing FinanceModels\ny = fit(Spline.Linear(),ForwardYields([0.05,0.1]),Bootstrap())\npv(y,cfs)\n","category":"page"},{"location":"API/FinanceCore/#FinanceCore-API-Reference","page":"FinanceCore","title":"FinanceCore API Reference","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]","category":"page"},{"location":"API/FinanceCore/#Exported-API","page":"FinanceCore","title":"Exported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]\nPrivate = false","category":"page"},{"location":"API/FinanceCore/#FinanceCore.Composite","page":"FinanceCore","title":"FinanceCore.Composite","text":"Summary ≡≡≡≡≡≡≡≡≡\n\nstruct Composite{A, B}\n\nA Composite{A,B} is a contract that is composed of two other contracts of type A and type B.  The maturity of the composite is the maximum of the maturities of the two components. \n\nIt is used to assemble arbitrarily complex contracts from simpler ones.\n\nFields ≡≡≡≡≡≡≡≡\n\na :: A\nb :: B\n\nSupertype Hierarchy ≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡≡\n\nComposite{A, B} <: FinanceCore.AbstractContract <: Any\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous","page":"FinanceCore","title":"FinanceCore.Continuous","text":"Continuous()\n\nA type representing continuous interest compounding frequency.\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Continuous-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Continuous","text":"julia> Continuous(0.01)\nRate(0.01, Continuous())\n\nSee also: Periodic\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Periodic","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(frequency)\n\nA type representing periodic interest compounding with the given frequency. \n\nfrequency will be converted to an Integer, and will round up to 8 decimal places (otherwise will throw an InexactError). \n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Periodic-Tuple{Any, Any}","page":"FinanceCore","title":"FinanceCore.Periodic","text":"Periodic(rate,frequency)\n\nA convenience constructor for Rate(rate,Periodic(frequency)).\n\nExamples\n\nCreating a semi-annual bond equivalent yield:\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\nSee also: Continuous\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.Quote","page":"FinanceCore","title":"FinanceCore.Quote","text":"Quote(price,instrument)\n\nThe price(<:Real) is the observed value , and the instrument is the instrument/contract that the price is for.\n\nThis can be used, e.g., to calibrate a valuation model to prices for the given instruments - see FinanceModels.jl for more details.\n\n\n\n\n\n","category":"type"},{"location":"API/FinanceCore/#FinanceCore.Rate-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.Rate","text":"Rate(rate[,frequency=1])\nRate(rate,frequency::Frequency)\n\nRate is a type that encapsulates an interest rate along with its compounding frequency.\n\nPeriodic rates can be constructed via Rate(rate,frequency) or Rate(rate,Periodic(frequency)). If not given a second argument, Rate(rate) is equivalent to Rate(rate,Periodic(1)).\n\nContinuous rates can be constructed via Rate(rate, Inf) or Rate(rate,Continuous()).\n\nExamples\n\njulia> Rate(0.01,Continuous())\nRate(0.01, Continuous())\n\njulia> Continuous(0.01)\nRate(0.01, Continuous())\n\njulia> Continuous()(0.01)\nRate(0.01, Continuous())\n\njulia> Rate(0.01,Periodic(2))\nRate(0.01, Periodic(2))\n\njulia> Periodic(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Periodic(2)(0.01)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01)\nRate(0.01, Periodic(1))\n\njulia> Rate(0.01,2)\nRate(0.01, Periodic(2))\n\njulia> Rate(0.01,Periodic(4))\nRate(0.01, Periodic(4))\n\njulia> Rate(0.01,Inf)\nRate(0.01, Continuous())\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.amount-Tuple{C} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.amount","text":"amount(x)\n\nIf is an object with an amount component (e.g. a Cashflow), will retrun that amount component, otherwise just x.\n\nExamples\n\njulia> FinanceCore.amount(Cashflow(1.,3.))\n1.0\n\njulia> FinanceCore.amount(1.)\n1.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.internal_rate_of_return-Tuple{Any}","page":"FinanceCore","title":"FinanceCore.internal_rate_of_return","text":"internal_rate_of_return(cashflows::vector)::Rate\ninternal_rate_of_return(cashflows::Vector, timepoints::Vector)::Rate\n\nCalculate the internalrateof_return with given timepoints. If no timepoints given, will assume that a series of equally spaced cashflows, assuming the first cashflow occurring at time zero and subsequent elements at time 1, 2, 3, ..., n. \n\nReturns a Rate type with periodic compounding once per period (e.g. annual effective if the timepoints given represent years). Get the scalar rate by calling Yields.rate() on the result.\n\nExample\n\njulia> internal_rate_of_return([-100,110],[0,1]) # e.g. cashflows at time 0 and 1\n0.10000000001652906\njulia> internal_rate_of_return([-100,110]) # implied the same as above\n0.10000000001652906\n\nSolver notes\n\nWill try to return a root within the range [-2,2]. If the fast solver does not find one matching this condition, then a more robust search will be performed over the [.99,2] range.\n\nThe solution returned will be in the range [-2,2], but may not be the one nearest zero. For a slightly slower, but more robust version, call ActuaryUtilities.irr_robust(cashflows,timepoints) directly.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.irr","page":"FinanceCore","title":"FinanceCore.irr","text":"irr(cashflows::vector)\nirr(cashflows::Vector, timepoints::Vector)\n\nAn alias for `internal_rate_of_return`.\n\n\n\n\n\n","category":"function"},{"location":"API/FinanceCore/#FinanceCore.present_value-Tuple{Any, Any, Any}","page":"FinanceCore","title":"FinanceCore.present_value","text":"present_value(yield_model, cashflows[, timepoints=pairs(cashflows)])\n\nDiscount the cashflows vector at the given yield_model,  with the cashflows occurring at the times specified in timepoints. If no timepoints given, assumes that cashflows happen at the indices of the cashflows.\n\nIf your timepoints are dates, you can convert them into a floating point representation of the time interval using DayCounts.jl.\n\nExamples\n\njulia> present_value(0.1, [10,20],[0,1])\n28.18181818181818\njulia> present_value(Continuous(0.1), [10,20],[0,1])\n28.096748360719193\njulia> present_value(Continuous(0.1), [10,20],[1,2])\n25.422989241919232\njulia> present_value(Continuous(0.1), [10,20])\n25.422989241919232\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.rate-Tuple{Rate}","page":"FinanceCore","title":"FinanceCore.rate","text":"rate(r::Rate)\n\nReturns the untyped scalar interest rate represented by the Rate.\n\nExamples\n\njulia> r =Continuous(0.03)\nYields.Rate{Float64, Continuous}(0.03, Continuous())\n\njulia> rate(r)\n0.03\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#FinanceCore.timepoint-Union{Tuple{C}, Tuple{C, Any}} where C<:Cashflow","page":"FinanceCore","title":"FinanceCore.timepoint","text":"timepoint(x,t)\n\nIf x is an object with a defined time component (e.g. a Cashflow), will return that time component, otherwise will return t. This is useful in handling situations where you want to handle either Cashflows or separate amount and time vectors.\n\nExample\n\njulia> FinanceCore.timepoint(Cashflow(1.,3.),\"ignored\")\n3.0\n\njulia> FinanceCore.timepoint(1.,4.)\n4.0\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Unexported-API","page":"FinanceCore","title":"Unexported API","text":"","category":"section"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Modules = [FinanceCore]\nPublic = false","category":"page"},{"location":"API/FinanceCore/#Base.:*-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:*","text":"*(Yields.Rate, T)\n*(T, Yields.Rate)\n\nThe multiplication of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:+-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:+","text":"+(Yields.Rate, T<:Real)\n+(T<:Real, Yields.Rate)\n+(Yields.Rate,Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.01,2) + Yields.Periodic(0.04,2)\nYields.Rate{Float64, Yields.Periodic}(0.05000000000000004, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) + 0.01\nYields.Rate{Float64, Yields.Periodic}(0.05, Yields.Periodic(2))\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:--Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:-","text":"-(Yields.Rate, T<:Real)\n-(T<:Real, Yields.Rate)\n-(Yields.Rate, Yields.Rate)\n\nThe addition of a rate with a number will inherit the type of the Rate, or the first argument's type if both are Rates.\n\nExamples\n\njulia> Yields.Periodic(0.04,2) - Yields.Periodic(0.01,2)\nYields.Rate{Float64, Yields.Periodic}(0.030000000000000214, Yields.Periodic(2))\n\njulia> Yields.Periodic(0.04,2) - 0.01\nYields.Rate{Float64, Yields.Periodic}(0.03, Yields.Periodic(2))\n\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:/-Union{Tuple{T}, Tuple{N}, Tuple{Rate{N, T}, Real}} where {N, T<:Continuous}","page":"FinanceCore","title":"Base.:/","text":"/(x::Yields.Rate, y::Real)\n\nThe division of a Rate with a scalar will inherit the type of the Rate, or the first argument's type if both are Rates.\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:<-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore","title":"Base.:<","text":"<(x::Rate,y::Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a lower force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) < Yields.Continuous(0.03)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.:>-Union{Tuple{U}, Tuple{T}, Tuple{T, U}} where {T<:Rate, U<:Rate}","page":"FinanceCore","title":"Base.:>","text":">(Rate,Rate)\n\nConvert the second argument to the periodicity of the first and compare the scalar rate values to determine if the first argument has a greater force of interest than the second.\n\nExamples\n\njulia> Yields.Periodic(0.03,100) > Yields.Continuous(0.03)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/#Base.convert-Union{Tuple{T}, Tuple{T, Rate}} where T<:FinanceCore.Frequency","page":"FinanceCore","title":"Base.convert","text":"convert(cf::Frequency,r::Rate)\n\nReturns a Rate with an equivalent discount but represented with a different compounding frequency.\n\nExamples\n\njulia> r = Rate(Periodic(12),0.01)\nRate(0.01, Periodic(12))\n\njulia> convert(Periodic(1),r)\nRate(0.010045960887181016, Periodic(1))\n\njulia> convert(Continuous(),r)\nRate(0.009995835646701251, Continuous())\n\n\n\n\n\n","category":"method"},{"location":"API/FinanceCore/","page":"FinanceCore","title":"FinanceCore","text":"Please open an issue if you encounter any issues or confusion with the package.","category":"page"},{"location":"#Quickstart","page":"Introduction","title":"Quickstart","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"cfs = [5, 5, 105]\ntimes    = [1, 2, 3]\n\ndiscount_rate = 0.03\n\npresent_value(discount_rate, cfs, times)           # 105.65\nduration(Macaulay(), discount_rate, cfs, times)    #   2.86\nduration(discount_rate, cfs, times)                #   2.78\nconvexity(discount_rate, cfs, times)               #  10.62","category":"page"},{"location":"#Features","page":"Introduction","title":"Features","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A collection of common functions/manipulations used in Actuarial Calculations.","category":"page"},{"location":"#Financial-Maths","page":"Introduction","title":"Financial Maths","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"duration:\nCalculate the Macaulay, Modified, or DV01 durations for a set of cashflows\nCalculate the KeyRate(time) (a.k.a. KeyRateZero)duration or KeyRatePar(time) duration\nconvexity for price sensitivity\nFlexible interest rate models via the FinanceModels.jl package.\ninternal_rate_of_return or irr to calculate the IRR given cashflows (including at timepoints like Excel's XIRR)\nbreakeven to calculate the breakeven time for a set of cashflows\naccum_offset to calculate accumulations like survivorship from a mortality vector\nspread will calculate the spread needed between two yield curves to equate a set of cashflows","category":"page"},{"location":"#Options-Pricing","page":"Introduction","title":"Options Pricing","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"eurocall and europut for Black-Scholes option prices (note: API may change for this in future)","category":"page"},{"location":"#Risk-Measures","page":"Introduction","title":"Risk Measures","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Calculate risk measures for a given vector of risks:\nCTE for the Conditional Tail Expectation, or\nVaR for the percentile/Value at Risk.","category":"page"},{"location":"#Insurance-mechanics","page":"Introduction","title":"Insurance mechanics","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"duration:\nCalculate the duration given an issue date and date (a.k.a. policy duration)","category":"page"},{"location":"#Typed-Rates","page":"Introduction","title":"Typed Rates","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"functions which return a rate/yield will return a FinanceCore.Rate object. E.g. irr(cashflows) will return a Rate(0.05,Periodic(1)) instead of just a 0.05 (float64) to convey the compounding frequency. This is compatible across the JuliaActuary ecosystem and can be used anywhere you would otherwise use a simple floating point rate.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"A couple of other notes:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"rate(...) will return the scalar rate value from a Rate struct:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> r = Rate(0.05,Periodic(1));\n\njulia> rate(r) \n0.05","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You can still pass a simple floating point rate to various methods. E.g. these two are the same (the default compounding convention is periodic once per period):","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"discount(0.05,cashflows)\n\nr = Rate(0.05,Periodic(1));\ndiscount(r,cashflows)","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"convert between rates with:","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"r = Rate(0.05,Periodic(1));\n\nconvert(Periodic(2),  r)   # convert to compounded twice per timestep\nconvert(Continuous(2),r)   # convert to compounded twice per timestep","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For more on Rates, see FinanceCore.jl. FinanceModels.jl also provides a rich and flexible set of yield models to use.","category":"page"},{"location":"#Documentation","page":"Introduction","title":"Documentation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Full documentation is available here.","category":"page"},{"location":"#Examples","page":"Introduction","title":"Examples","text":"","category":"section"},{"location":"#Interactive,-basic-cashflow-analysis","page":"Introduction","title":"Interactive, basic cashflow analysis","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"See JuliaActuary.org for instructions on running this example.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"(Image: Simple cashflow analysis with ActuaryUtilities.jl)","category":"page"},{"location":"#Useful-tips","page":"Introduction","title":"Useful tips","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Functions often use a mix of interest_rates, cashflows, and timepoints. When calling functions, the general order of the arguments is 1) interest rates, 2) cashflows, and 3) timepoints.","category":"page"}]
}
